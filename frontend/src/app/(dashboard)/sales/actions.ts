'use server'

import { createClient } from '@/lib/supabase/server'
import { CreateOrderInput, UpdateOrderInput, GroupedSalesOrder, SalesOrder, SalesStoryAggregates, SalesAggregates } from '@/types/sales'
import { toBangkokTime, formatBangkok, getBangkokNow } from '@/lib/bangkok-time'
import { unstable_noStore as noStore } from 'next/cache'
import { toBangkokDateString } from '@/lib/bangkok-date-range'

interface ActionResult {
  success: boolean
  error?: string
  data?: unknown
}

export async function createManualOrder(input: CreateOrderInput): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Validate input
    if (!input.product_name || input.product_name.trim() === '') {
      return { success: false, error: 'กรุณากระอกชื่อสินค้า' }
    }

    if (input.quantity <= 0) {
      return { success: false, error: 'จำนวนต้องมากกว่า 0' }
    }

    if (input.unit_price < 0) {
      return { success: false, error: 'ราคาต่อหน่วยต้องไม่ติดลบ' }
    }

    if (!input.order_date) {
      return { success: false, error: 'กรุณาระบุวันที่สั่งซื้อ' }
    }

    // 3. Calculate total_amount (server-side, cannot be trusted from client)
    // BUSINESS RULE: Total amount must be calculated server-side to prevent tampering
    // BUSINESS RULE: Cancelled orders must have total_amount = 0 (excluded from revenue)
    // FINANCIAL SAFETY: Round to 2 decimal places (currency precision)
    let totalAmount: number

    if (input.status.toLowerCase() === 'cancelled') {
      totalAmount = 0
    } else {
      const rawAmount = input.quantity * input.unit_price
      // Round to 2 decimal places to prevent floating point errors
      totalAmount = Math.round(rawAmount * 100) / 100
    }

    // 4. Generate order_id in format: MAN-YYYYMMDD-XXX
    const orderDate = toBangkokTime(input.order_date)
    const dateStr = formatBangkok(orderDate, 'yyyyMMdd')
    const prefix = `MAN-${dateStr}`

    // Query existing manual orders for today to get counter
    const { data: existingOrders, error: queryError } = await supabase
      .from('sales_orders')
      .select('order_id')
      .ilike('order_id', `${prefix}%`)
      .order('order_id', { ascending: false })
      .limit(1)

    if (queryError) {
      console.error('Error querying existing orders:', queryError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการตรวจสอบ order id' }
    }

    let counter = 1
    if (existingOrders && existingOrders.length > 0) {
      const lastOrderId = existingOrders[0].order_id
      const lastCounter = parseInt(lastOrderId.split('-')[2] || '0')
      counter = lastCounter + 1
    }

    const orderId = `${prefix}-${counter.toString().padStart(3, '0')}`

    // 5. Insert order into database
    // AUDIT SAFETY: Every record must have source and created_by for traceability
    // source = 'manual' | 'csv' | 'api' - identifies data origin
    // created_by = user.id - tracks who created this record
    // created_at = auto-generated by Supabase - timestamp
    // CRITICAL: Manual entries must never be overwritten by imports
    const { data: insertedOrder, error: insertError } = await supabase
      .from('sales_orders')
      .insert({
        order_id: orderId,
        marketplace: input.marketplace,
        product_name: input.product_name.trim(),
        quantity: input.quantity,
        unit_price: input.unit_price,
        total_amount: totalAmount,
        order_date: input.order_date,
        status: input.status,
        source: 'manual', // AUDIT: Mark as manually entered
        created_by: user.id, // AUDIT: Track creator
      })
      .select()
      .single()

    if (insertError) {
      console.error('Error inserting order:', insertError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${insertError.message}` }
    }

    return { success: true, data: insertedOrder }
  } catch (error) {
    console.error('Unexpected error in createManualOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

export async function updateOrder(
  orderId: string,
  input: UpdateOrderInput
): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Validate input
    if (!input.product_name || input.product_name.trim() === '') {
      return { success: false, error: 'กรุณากรอกชื่อสินค้า' }
    }

    if (input.quantity <= 0) {
      return { success: false, error: 'จำนวนต้องมากกว่า 0' }
    }

    if (input.unit_price < 0) {
      return { success: false, error: 'ราคาต่อหน่วยต้องไม่ติดลบ' }
    }

    if (!input.order_date) {
      return { success: false, error: 'กรุณาระบุวันที่สั่งซื้อ' }
    }

    // 3. Check if order exists and belongs to user (RLS will also enforce this)
    const { data: existingOrder, error: fetchError } = await supabase
      .from('sales_orders')
      .select('id, created_by')
      .eq('id', orderId)
      .single()

    if (fetchError || !existingOrder) {
      return { success: false, error: 'ไม่พบรายการ order ที่ต้องการแก้ไข' }
    }

    // Check ownership (defensive - RLS should also prevent this)
    if (existingOrder.created_by !== user.id) {
      return { success: false, error: 'คุณไม่มีสิทธิ์แก้ไข order นี้' }
    }

    // 4. Calculate total_amount (server-side, cannot be trusted from client)
    let totalAmount: number

    if (input.status.toLowerCase() === 'cancelled') {
      totalAmount = 0
    } else {
      const rawAmount = input.quantity * input.unit_price
      totalAmount = Math.round(rawAmount * 100) / 100
    }

    // 5. Update order in database
    const { data: updatedOrder, error: updateError } = await supabase
      .from('sales_orders')
      .update({
        marketplace: input.marketplace,
        product_name: input.product_name.trim(),
        quantity: input.quantity,
        unit_price: input.unit_price,
        total_amount: totalAmount,
        order_date: input.order_date,
        status: input.status,
        updated_at: new Date().toISOString(),
      })
      .eq('id', orderId)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating order:', updateError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${updateError.message}` }
    }

    return { success: true, data: updatedOrder }
  } catch (error) {
    console.error('Unexpected error in updateOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

export async function deleteOrder(orderId: string): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Check if order exists and belongs to user (RLS will also enforce this)
    const { data: existingOrder, error: fetchError } = await supabase
      .from('sales_orders')
      .select('id, created_by, order_id')
      .eq('id', orderId)
      .single()

    if (fetchError || !existingOrder) {
      return { success: false, error: 'ไม่พบรายการ order ที่ต้องการลบ' }
    }

    // Check ownership (defensive - RLS should also prevent this)
    if (existingOrder.created_by !== user.id) {
      return { success: false, error: 'คุณไม่มีสิทธิ์ลบ order นี้' }
    }

    // 3. Hard delete from database
    const { error: deleteError } = await supabase
      .from('sales_orders')
      .delete()
      .eq('id', orderId)

    if (deleteError) {
      console.error('Error deleting order:', deleteError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${deleteError.message}` }
    }

    return { success: true, data: { deletedId: orderId } }
  } catch (error) {
    console.error('Unexpected error in deleteOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

interface ExportFilters {
  marketplace?: string // Legacy (keep for backward compat)
  sourcePlatform?: string // UX v2: tiktok_shop | shopee | etc
  status?: string[] // UX v2: Multi-select status filter
  paymentStatus?: string // UX v2: paid | unpaid
  startDate?: string
  endDate?: string
  search?: string
  view?: 'order' | 'line' // Order View / Line View
  dateBasis?: 'order' | 'paid' // Date filtering basis (TikTok timestamps)
}

interface ExportResult {
  success: boolean
  error?: string
  csv?: string
  filename?: string
}

/**
 * Export Sales Orders to CSV
 * Respects all filters (marketplace, date range, search)
 * Returns CSV content and filename with Bangkok timezone
 *
 * CRITICAL:
 * - If view=order: Export grouped orders (1 row per order_id)
 * - If view=line: Export raw lines (default behavior)
 */
export async function exportSalesOrders(filters: ExportFilters): Promise<ExportResult> {
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const view = filters.view || 'line'
    const dateBasis = filters.dateBasis || 'order'

    // 2. Branch: Order View vs Line View
    if (view === 'order') {
      // Order View Export: Use grouped data (1 row per order)
      const groupedResult = await getSalesOrdersGrouped({
        sourcePlatform: filters.sourcePlatform,
        status: filters.status,
        paymentStatus: filters.paymentStatus,
        startDate: filters.startDate,
        endDate: filters.endDate,
        search: filters.search,
        dateBasis: dateBasis,
        page: 1,
        perPage: 10000, // Export all (with reasonable limit)
      })

      if (!groupedResult.success || !groupedResult.data || groupedResult.data.length === 0) {
        return { success: false, error: 'ไม่พบข้อมูลที่จะ export' }
      }

      // Generate CSV for Order View (Order-level columns)
      const headers = [
        'External Order ID',
        'Created Time',
        'Paid Time',
        'Cancelled Time',
        'Gross Amount',
        'Total Units',
        'SKU Lines',
        'Payment Method',
        'Cancel Same Day Flag',
      ]

      const escapeCSV = (value: string | number | null | undefined): string => {
        if (value === null || value === undefined) return ''
        const str = String(value)
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
          return `"${str.replace(/"/g, '""')}"`
        }
        return str
      }

      const rows = groupedResult.data.map((order) => {
        // Calculate cancel_same_day_flag (if cancelled_time exists and is same day as created_time)
        let cancelSameDayFlag = 'N'
        if (order.cancelled_time && order.created_time) {
          try {
            const createdDate = new Date(order.created_time).toLocaleDateString('en-CA', { timeZone: 'Asia/Bangkok' })
            const cancelledDate = new Date(order.cancelled_time).toLocaleDateString('en-CA', { timeZone: 'Asia/Bangkok' })
            cancelSameDayFlag = createdDate === cancelledDate ? 'Y' : 'N'
          } catch {
            cancelSameDayFlag = 'N'
          }
        }

        // Extract payment_method from metadata if available (first line's metadata)
        // This is a simplified approach; actual implementation may need to query lines
        const paymentMethod = order.payment_status === 'paid' ? 'Online' : 'COD' // Simplified

        return [
          escapeCSV(order.external_order_id || order.order_id),
          escapeCSV(order.created_time || order.order_date),
          escapeCSV(order.paid_time || order.paid_at || ''),
          escapeCSV(order.cancelled_time || ''),
          escapeCSV(order.order_amount),
          escapeCSV(order.total_units),
          escapeCSV(order.sku_count),
          escapeCSV(paymentMethod),
          escapeCSV(cancelSameDayFlag),
        ].join(',')
      })

      const csvContent = [headers.join(','), ...rows].join('\n')
      const now = getBangkokNow()
      const dateStr = formatBangkok(now, 'yyyyMMdd-HHmmss')
      const filename = `sales-orders-grouped-${dateStr}.csv`

      return {
        success: true,
        csv: csvContent,
        filename,
      }
    }

    // Line View Export: Use raw line data (original behavior)
    // 3. Build query with filters (UX v2 logic)
    // IMPORTANT: Select order_date for fallback in case created_time is NULL
    let query = supabase
      .from('sales_orders')
      .select('*')

    // Order by based on date basis (TikTok timestamps)
    // Note: Rows with NULL created_time will appear last (nullsFirst: false)
    if (dateBasis === 'order') {
      query = query.order('created_time', { ascending: false, nullsFirst: false })
    } else {
      query = query.order('paid_time', { ascending: false, nullsFirst: false })
    }

    // Platform filter (UX v2)
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      query = query.eq('source_platform', filters.sourcePlatform)
    } else if (filters.marketplace && filters.marketplace !== 'All') {
      // Legacy fallback
      query = query.eq('marketplace', filters.marketplace)
    }

    // Status filter (multi-select, UX v2) - filters by platform_status (Thai values)
    if (filters.status && filters.status.length > 0) {
      query = query.in('platform_status', filters.status)
    }

    // Payment status filter (UX v2)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      query = query.eq('payment_status', filters.paymentStatus)
    }

    // Apply date filters based on date basis (TikTok timestamps)
    // CRITICAL FIX (migration-030): Use COALESCE(created_time, order_date) logic
    if (dateBasis === 'order') {
      // Fetch by order_date (broader) to include created_time=NULL rows
      if (filters.startDate) {
        query = query.gte('order_date', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        query = query.lte('order_date', endOfDayBangkok.toISOString())
      }
    } else {
      // For paid basis, filter out null paid_time
      query = query.not('paid_time', 'is', null)
      if (filters.startDate) {
        query = query.gte('paid_time', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        query = query.lte('paid_time', endOfDayBangkok.toISOString())
      }
    }

    // Apply search filter (UX v2 includes external_order_id)
    if (filters.search && filters.search.trim()) {
      query = query.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // No pagination - export all matching records
    // Add reasonable limit to prevent memory issues
    query = query.limit(10000)

    const { data: rawOrders, error: fetchError } = await query

    if (fetchError) {
      console.error('Error fetching orders for export:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawOrders || rawOrders.length === 0) {
      return { success: false, error: 'ไม่พบข้อมูลที่จะ export' }
    }

    // CLIENT-SIDE FILTERING WITH COALESCE(created_time, order_date)
    // CRITICAL FIX: Fetch by order_date (broader), filter by effective_date
    const orders = rawOrders.filter(order => {
      if (dateBasis === 'paid') {
        // Paid basis already filtered at DB level
        return true
      }

      // Order basis: Use COALESCE(created_time, order_date)
      const effectiveDate = order.created_time || order.order_date

      if (!effectiveDate) {
        console.warn('Export: Order with no created_time or order_date:', order.order_id)
        return false
      }

      // Convert to Bangkok date for date-only comparison (SAFE: uses Bangkok timezone)
      const bangkokDateStr = toBangkokDateString(new Date(effectiveDate))

      if (filters.startDate) {
        if (bangkokDateStr < filters.startDate) return false
      }

      if (filters.endDate) {
        if (bangkokDateStr > filters.endDate) return false
      }

      return true
    })

    if (orders.length === 0) {
      return { success: false, error: 'ไม่พบข้อมูลที่จะ export' }
    }

    // 3. Generate CSV content (UX v2 with platform status & payment)
    // CSV Headers (English for Excel compatibility)
    const headers = [
      'Order ID',
      'External Order ID',
      'Platform',
      'Product Name',
      'Quantity',
      'Unit Price',
      'Total Amount',
      'Internal Status',
      'Platform Status',
      'Status Group',
      'Payment Status',
      'Paid Date',
      'Order Date',
      'Created At',
    ]

    // Escape CSV field (handle commas, quotes, newlines)
    const escapeCSV = (value: string | number | null | undefined): string => {
      if (value === null || value === undefined) return ''
      const str = String(value)
      // If contains comma, quote, or newline, wrap in quotes and escape quotes
      if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return `"${str.replace(/"/g, '""')}"`
      }
      return str
    }

    // Build CSV rows (UX v2 with platform status & payment)
    const rows = orders.map((order) => {
      return [
        escapeCSV(order.order_id),
        escapeCSV(order.external_order_id || ''),
        escapeCSV(order.source_platform || order.marketplace),
        escapeCSV(order.product_name),
        escapeCSV(order.quantity),
        escapeCSV(order.unit_price),
        escapeCSV(order.total_amount),
        escapeCSV(order.status),
        escapeCSV(order.platform_status || ''),
        escapeCSV(order.status_group || ''),
        escapeCSV(order.payment_status || ''),
        escapeCSV(order.paid_at || ''),
        escapeCSV(order.order_date),
        escapeCSV(order.created_at),
      ].join(',')
    })

    // Combine headers and rows
    const csvContent = [headers.join(','), ...rows].join('\n')

    // 4. Generate filename with Bangkok timezone
    const now = getBangkokNow()
    const dateStr = formatBangkok(now, 'yyyyMMdd-HHmmss')
    const filename = `sales-orders-${dateStr}.csv`

    return {
      success: true,
      csv: csvContent,
      filename,
    }
  } catch (error) {
    console.error('Unexpected error in exportSalesOrders:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Sales Aggregates (Summary Metrics)
 * Computes summary metrics for Sales Orders page
 * Uses SAME filters as getSalesOrders to prevent drift
 *
 * CRITICAL:
 * - Uses order-level aggregation (1 row per order_id)
 * - Date filtering uses paid_at or order_date based on dateBasis param
 */
/**
 * Get Sales Aggregates with TikTok Business Timestamp Semantics
 *
 * Key Concepts:
 * - Uses TikTok business timestamps (created_time, paid_time, cancelled_time) NOT DB timestamps
 * - dateBasis: "order" filters by created_time, "paid" filters by paid_time (with IS NOT NULL check)
 * - Same-day cancel: DATE(cancelled_time) = DATE(created_time) in Bangkok timezone
 * - Order-level aggregation: Groups by external_order_id, uses MAX(total_amount) per order (not SUM across lines)
 * - Import completeness verification: compares orders_distinct vs lines_total
 *
 * @param filters - Export filters with date range, platform, status, and dateBasis
 * @returns SalesAggregates with revenue_net/gross, orders_net/gross, cancel rates, units, AOV, completeness metrics
 */
export async function getSalesAggregates(filters: ExportFilters & { dateBasis?: 'order' | 'paid' }): Promise<{
  success: boolean
  data?: SalesAggregates
  error?: string
}> {
  noStore() // Prevent Next.js caching
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const dateBasis = filters.dateBasis || 'order' // Default to created_time-based

    // 2. Build base query with filters
    // IMPORTANT: Select order_date for fallback (legacy data where created_time is NULL)
    let baseQuery = supabase
      .from('sales_orders')
      .select('external_order_id, order_id, total_amount, quantity, created_time, paid_time, cancelled_time, order_date, source_platform, platform_status, payment_status')

    // Platform filter (UX v2)
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    } else if (filters.marketplace && filters.marketplace !== 'All') {
      // Legacy fallback
      baseQuery = baseQuery.eq('marketplace', filters.marketplace)
    }

    // Status filter (multi-select, UX v2) - filters by platform_status (Thai values)
    if (filters.status && filters.status.length > 0) {
      baseQuery = baseQuery.in('platform_status', filters.status)
    }

    // Payment status filter (UX v2)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      baseQuery = baseQuery.eq('payment_status', filters.paymentStatus)
    }

    // Date filtering based on dateBasis (TikTok timestamps)
    // CRITICAL FIX (migration-030): Use COALESCE(created_time, order_date) logic
    // Problem: DB filter "created_time >= startDate" excludes rows with created_time=NULL
    // Solution: Fetch broader dataset and filter client-side with fallback
    if (dateBasis === 'paid') {
      // Filter by paid_time (only include paid orders)
      baseQuery = baseQuery.not('paid_time', 'is', null)

      if (filters.startDate) {
        baseQuery = baseQuery.gte('paid_time', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('paid_time', endOfDayBangkok.toISOString())
      }
    } else {
      // Filter by COALESCE(created_time, order_date) - fetch both and filter client-side
      // IMPORTANT: Don't filter by created_time at DB level → excludes NULL rows
      // Instead: Fetch by order_date (broader) and filter client-side with COALESCE logic

      if (filters.startDate) {
        // Fetch rows where:
        // 1. created_time >= startDate (rows with created_time)
        // 2. OR created_time IS NULL AND order_date >= startDate (fallback rows)
        // Since Supabase doesn't support COALESCE in filter, fetch broader set:
        baseQuery = baseQuery.gte('order_date', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('order_date', endOfDayBangkok.toISOString())
      }

      // Client-side filter will apply COALESCE(created_time, order_date) logic below
    }

    // Apply search filter (UX v2 includes external_order_id)
    if (filters.search && filters.search.trim()) {
      baseQuery = baseQuery.or(
        `order_id.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // 3. Fetch all matching line items
    const { data: rawLines, error: fetchError } = await baseQuery

    if (fetchError) {
      console.error('Error fetching orders for aggregates:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawLines || rawLines.length === 0) {
      // Return zero aggregates if no data
      return {
        success: true,
        data: {
          revenue_gross: 0,
          revenue_net: 0,
          cancelled_same_day_amount: 0,
          cancel_rate_revenue_pct: 0,
          orders_gross: 0,
          orders_net: 0,
          cancelled_same_day_orders: 0,
          cancel_rate_orders_pct: 0,
          total_units: 0,
          aov_net: 0,
          orders_distinct: 0,
          lines_total: 0,
          total_lines: 0,
          total_orders: 0,
          lines_per_order: 0,
        },
      }
    }

    // 3.5. CLIENT-SIDE DATE FILTERING WITH COALESCE(created_time, order_date)
    // CRITICAL FIX: Now we fetch by order_date (broader), must filter by effective_date
    const lines = rawLines.filter(line => {
      if (dateBasis === 'paid') {
        // Paid basis already filtered at DB level (paid_time NOT NULL)
        return true
      }

      // Order basis: Use COALESCE(created_time, order_date) = effective_date
      const effectiveDate = line.created_time || line.order_date

      if (!effectiveDate) {
        // No date at all (should never happen for valid data) - exclude
        console.warn('getSalesAggregates: Order with no created_time or order_date:', line.order_id)
        return false
      }

      // Convert to Bangkok date for date-only comparison (YYYY-MM-DD)
      const { toZonedTime } = require('date-fns-tz')
      const bangkokDate = toZonedTime(new Date(effectiveDate), 'Asia/Bangkok')
      const bangkokDateStr = bangkokDate.toISOString().split('T')[0] // YYYY-MM-DD

      // Apply date filters (startDate and endDate are YYYY-MM-DD strings)
      if (filters.startDate) {
        if (bangkokDateStr < filters.startDate) return false
      }

      if (filters.endDate) {
        if (bangkokDateStr > filters.endDate) return false
      }

      return true
    })

    // Log warning if we found rows with NULL created_time (should be rare)
    const nullCreatedTimeCount = rawLines.filter(l => !l.created_time).length
    if (nullCreatedTimeCount > 0 && dateBasis === 'order') {
      console.warn(`Found ${nullCreatedTimeCount} rows with NULL created_time (using order_date fallback)`)
    }

    if (lines.length === 0) {
      // All rows filtered out after fallback logic
      return {
        success: true,
        data: {
          revenue_gross: 0,
          revenue_net: 0,
          cancelled_same_day_amount: 0,
          cancel_rate_revenue_pct: 0,
          orders_gross: 0,
          orders_net: 0,
          cancelled_same_day_orders: 0,
          cancel_rate_orders_pct: 0,
          total_units: 0,
          aov_net: 0,
          orders_distinct: 0,
          lines_total: 0,
          total_lines: 0,
          total_orders: 0,
          lines_per_order: 0,
        },
      }
    }

    // 4. CRITICAL: Group by external_order_id to prevent multi-SKU revenue inflation
    // Build order-level aggregates first (1 row per order_id)
    const orderMap = new Map<string, {
      order_id: string
      external_order_id: string | null
      order_amount: number // MAX(total_amount) across lines (should be same, use MAX for safety)
      total_units: number // SUM(quantity) across lines
      created_time: string | null
      paid_time: string | null
      cancelled_time: string | null
      is_cancelled_same_day: boolean // DATE(cancelled_time) = DATE(created_time)
    }>()

    // Helper to check same-day cancel (Bangkok timezone)
    const isSameDayCancel = (createdTime: string | null, cancelledTime: string | null): boolean => {
      if (!createdTime || !cancelledTime) return false

      try {
        const createdDate = new Date(createdTime)
        const cancelledDate = new Date(cancelledTime)

        // Compare dates in Bangkok timezone (YYYY-MM-DD)
        const createdBkk = createdDate.toLocaleDateString('en-CA', { timeZone: 'Asia/Bangkok' })
        const cancelledBkk = cancelledDate.toLocaleDateString('en-CA', { timeZone: 'Asia/Bangkok' })

        return createdBkk === cancelledBkk
      } catch {
        return false
      }
    }

    for (const line of lines) {
      const orderId = line.external_order_id || line.order_id

      // FALLBACK: Use order_date if created_time is NULL (legacy data)
      const effectiveCreatedTime = line.created_time || line.order_date
      const isCancelledSameDay = isSameDayCancel(effectiveCreatedTime, line.cancelled_time)

      if (!orderMap.has(orderId)) {
        orderMap.set(orderId, {
          order_id: orderId,
          external_order_id: line.external_order_id,
          order_amount: line.total_amount || 0,
          total_units: line.quantity || 0,
          created_time: effectiveCreatedTime, // Use fallback value
          paid_time: line.paid_time,
          cancelled_time: line.cancelled_time,
          is_cancelled_same_day: isCancelledSameDay,
        })
      } else {
        const existing = orderMap.get(orderId)!
        existing.total_units += line.quantity || 0
        // Use MAX(total_amount) for safety (should be same across lines)
        existing.order_amount = Math.max(existing.order_amount, line.total_amount || 0)
        // Preserve cancelled_time if any line has it
        if (!existing.cancelled_time && line.cancelled_time) {
          existing.cancelled_time = line.cancelled_time
          existing.is_cancelled_same_day = isSameDayCancel(existing.created_time, line.cancelled_time)
        }
      }
    }

    // 5. Compute aggregates from order-level data
    let revenueGross = 0
    let cancelledSameDayAmount = 0
    let ordersGross = 0
    let cancelledSameDayOrders = 0
    let unitsNet = 0 // Only count units from net orders (exclude same-day cancelled)

    for (const order of Array.from(orderMap.values())) {
      // All orders contribute to gross
      revenueGross += order.order_amount
      ordersGross += 1

      // Check if cancelled same day
      if (order.is_cancelled_same_day) {
        cancelledSameDayAmount += order.order_amount
        cancelledSameDayOrders += 1
      } else {
        // Net orders (not cancelled same day)
        unitsNet += order.total_units
      }
    }

    // 6. Calculate derived metrics
    const revenueNet = revenueGross - cancelledSameDayAmount
    const ordersNet = ordersGross - cancelledSameDayOrders
    const cancelRateRevenuePct = revenueGross > 0 ? (cancelledSameDayAmount / revenueGross) * 100 : 0
    const cancelRateOrdersPct = ordersGross > 0 ? (cancelledSameDayOrders / ordersGross) * 100 : 0
    const aovNet = ordersNet > 0 ? revenueNet / ordersNet : 0

    // 7. Import completeness verification & Lines vs Orders ratio
    const ordersDistinct = orderMap.size // COUNT(DISTINCT external_order_id)
    const linesTotal = lines.length // COUNT(*) from raw table
    const linesPerOrder = ordersDistinct > 0 ? linesTotal / ordersDistinct : 0

    return {
      success: true,
      data: {
        revenue_gross: Math.round(revenueGross * 100) / 100,
        revenue_net: Math.round(revenueNet * 100) / 100,
        cancelled_same_day_amount: Math.round(cancelledSameDayAmount * 100) / 100,
        cancel_rate_revenue_pct: Math.round(cancelRateRevenuePct * 100) / 100,
        orders_gross: ordersGross,
        orders_net: ordersNet,
        cancelled_same_day_orders: cancelledSameDayOrders,
        cancel_rate_orders_pct: Math.round(cancelRateOrdersPct * 100) / 100,
        total_units: unitsNet,
        aov_net: Math.round(aovNet * 100) / 100,
        orders_distinct: ordersDistinct,
        lines_total: linesTotal,
        total_lines: linesTotal, // UI-friendly alias
        total_orders: ordersDistinct, // UI-friendly alias
        lines_per_order: Math.round(linesPerOrder * 100) / 100, // Ratio (2 decimals)
      },
    }
  } catch (error) {
    console.error('Unexpected error in getSalesAggregates:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get TikTok-Style Sales Aggregates
 * Uses created_at-based filtering (matches TikTok Seller Center semantics)
 * For reference/comparison purposes only - NOT used for business P&L
 *
 * CRITICAL:
 * - Always uses created_at for date filtering (ignores dateBasis)
 * - Counts DISTINCT orders created in date range
 * - Identifies cancelled orders within that created date range
 */
export interface TikTokStyleAggregates {
  total_created_orders: number // DISTINCT order count by created_at
  cancelled_created_orders: number // DISTINCT cancelled order count by created_at
  cancel_rate: number // cancelled / total (0-100%)
}

export async function getSalesAggregatesTikTokLike(filters: ExportFilters): Promise<{
  success: boolean
  data?: TikTokStyleAggregates
  error?: string
}> {
  noStore() // Prevent Next.js caching
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Build base query with filters
    // CRITICAL: Use created_at for date filtering (TikTok semantics)
    let baseQuery = supabase
      .from('sales_orders')
      .select('*')

    // Platform filter (UX v2)
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    } else if (filters.marketplace && filters.marketplace !== 'All') {
      // Legacy fallback
      baseQuery = baseQuery.eq('marketplace', filters.marketplace)
    }

    // Status filter (optional, for consistency with main view)
    if (filters.status && filters.status.length > 0) {
      baseQuery = baseQuery.in('platform_status', filters.status)
    }

    // Payment status filter (optional)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      baseQuery = baseQuery.eq('payment_status', filters.paymentStatus)
    }

    // Date filtering: ALWAYS use created_at (TikTok semantics)
    if (filters.startDate) {
      baseQuery = baseQuery.gte('created_at', filters.startDate)
    }
    if (filters.endDate) {
      const { toZonedTime } = await import('date-fns-tz')
      const { endOfDay } = await import('date-fns')
      const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
      const endOfDayBangkok = endOfDay(bangkokDate)
      baseQuery = baseQuery.lte('created_at', endOfDayBangkok.toISOString())
    }

    // Apply search filter (optional)
    if (filters.search && filters.search.trim()) {
      baseQuery = baseQuery.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // 3. Fetch all matching orders
    const { data: orders, error: fetchError } = await baseQuery

    if (fetchError) {
      console.error('Error fetching orders for TikTok aggregates:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!orders || orders.length === 0) {
      // Return zero aggregates if no data
      return {
        success: true,
        data: {
          total_created_orders: 0,
          cancelled_created_orders: 0,
          cancel_rate: 0,
        },
      }
    }

    // 4. Group by order_id to get distinct orders
    const orderMap = new Map<string, {
      order_id: string
      is_cancelled: boolean
    }>()

    for (const line of orders) {
      const orderId = line.external_order_id || line.order_id

      // Check if cancelled (use status_group if available, fallback to platform_status)
      const isCancelled =
        line.status_group?.toLowerCase().includes('ยกเลิก') ||
        line.platform_status?.toLowerCase().includes('ยกเลิก') ||
        false

      if (!orderMap.has(orderId)) {
        orderMap.set(orderId, {
          order_id: orderId,
          is_cancelled: isCancelled,
        })
      }
      // If already exists, keep is_cancelled status (should be same across lines)
    }

    // 5. Compute TikTok-style aggregates
    let totalCreatedOrders = 0
    let cancelledCreatedOrders = 0

    for (const order of Array.from(orderMap.values())) {
      totalCreatedOrders += 1
      if (order.is_cancelled) {
        cancelledCreatedOrders += 1
      }
    }

    // 6. Calculate cancel rate
    const cancelRate = totalCreatedOrders > 0
      ? (cancelledCreatedOrders / totalCreatedOrders) * 100
      : 0

    return {
      success: true,
      data: {
        total_created_orders: totalCreatedOrders,
        cancelled_created_orders: cancelledCreatedOrders,
        cancel_rate: Math.round(cancelRate * 100) / 100, // Round to 2 decimals
      },
    }
  } catch (error) {
    console.error('Unexpected error in getSalesAggregatesTikTokLike:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Sales Story Aggregates (Created-based, Same-day Cancel)
 * For 60/40 Story Panel: Net vs Gross + Same-day Cancel %
 *
 * CRITICAL:
 * - Always uses created_at for date filtering (ignores dateBasis)
 * - Same-day cancel: Orders cancelled on same calendar day as created
 * - Fallback mode (no cancelled_at field): All cancelled orders in range
 * - Must use order-level aggregation: MAX(total_amount) per order_id
 */
export async function getSalesStoryAggregates(filters: ExportFilters): Promise<{
  success: boolean
  data?: SalesStoryAggregates
  error?: string
}> {
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Build base query with filters
    // CRITICAL: Use created_at for date filtering (Story semantics)
    let baseQuery = supabase
      .from('sales_orders')
      .select('*')

    // Platform filter
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    } else if (filters.marketplace && filters.marketplace !== 'All') {
      baseQuery = baseQuery.eq('marketplace', filters.marketplace)
    }

    // Status filter (optional - default is all created orders)
    if (filters.status && filters.status.length > 0) {
      baseQuery = baseQuery.in('platform_status', filters.status)
    }

    // Payment status filter (optional - keep COD included by default)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      baseQuery = baseQuery.eq('payment_status', filters.paymentStatus)
    }

    // Date filtering: ALWAYS use created_at (Story semantics)
    if (filters.startDate) {
      baseQuery = baseQuery.gte('created_at', filters.startDate)
    }
    if (filters.endDate) {
      const { toZonedTime } = await import('date-fns-tz')
      const { endOfDay } = await import('date-fns')
      const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
      const endOfDayBangkok = endOfDay(bangkokDate)
      baseQuery = baseQuery.lte('created_at', endOfDayBangkok.toISOString())
    }

    // Search filter (optional)
    if (filters.search && filters.search.trim()) {
      baseQuery = baseQuery.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // 3. Fetch all matching orders
    const { data: orders, error: fetchError } = await baseQuery

    if (fetchError) {
      console.error('Error fetching orders for Story aggregates:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!orders || orders.length === 0) {
      // Return zero aggregates if no data
      return {
        success: true,
        data: {
          gross_revenue_created: 0,
          total_created_orders: 0,
          same_day_cancel_orders: 0,
          same_day_cancel_revenue: 0,
          net_revenue_after_same_day_cancel: 0,
          net_orders_after_same_day_cancel: 0,
          cancel_rate_same_day: 0,
          has_cancelled_at: false, // No cancelled_at field in schema
        },
      }
    }

    // 4. Group by order_id to get distinct orders
    const orderMap = new Map<string, {
      order_id: string
      order_amount: number
      is_cancelled: boolean
      created_at: string
    }>()

    for (const line of orders) {
      const orderId = line.external_order_id || line.order_id

      // Check if cancelled (use status_group if available, fallback to platform_status)
      const isCancelled =
        line.status_group?.toLowerCase().includes('ยกเลิก') ||
        line.platform_status?.toLowerCase().includes('ยกเลิก') ||
        false

      if (!orderMap.has(orderId)) {
        orderMap.set(orderId, {
          order_id: orderId,
          order_amount: line.total_amount || 0, // First line's order amount
          is_cancelled: isCancelled,
          created_at: line.created_at,
        })
      } else {
        const existing = orderMap.get(orderId)!
        // Order amount should be same across lines (use MAX as safety)
        existing.order_amount = Math.max(existing.order_amount, line.total_amount || 0)
      }
    }

    // 5. Compute Story aggregates
    let grossRevenueCreated = 0
    let totalCreatedOrders = 0
    let sameDayCancelOrders = 0
    let sameDayCancelRevenue = 0

    // FALLBACK MODE: Since no cancelled_at field exists, we treat all cancelled orders
    // in the created date range as "same-day cancel" (cannot verify actual cancel time)
    for (const order of Array.from(orderMap.values())) {
      totalCreatedOrders += 1
      grossRevenueCreated += order.order_amount

      if (order.is_cancelled) {
        // Fallback: All cancelled orders are counted as "same-day cancel"
        // (We cannot verify if they were actually cancelled on the same day)
        sameDayCancelOrders += 1
        sameDayCancelRevenue += order.order_amount
      }
    }

    // 6. Calculate net values
    const netRevenueAfterSameDayCancel = grossRevenueCreated - sameDayCancelRevenue
    const netOrdersAfterSameDayCancel = totalCreatedOrders - sameDayCancelOrders

    // 7. Calculate cancel rate
    const cancelRateSameDay = totalCreatedOrders > 0
      ? (sameDayCancelOrders / totalCreatedOrders) * 100
      : 0

    return {
      success: true,
      data: {
        gross_revenue_created: Math.round(grossRevenueCreated * 100) / 100,
        total_created_orders: totalCreatedOrders,
        same_day_cancel_orders: sameDayCancelOrders,
        same_day_cancel_revenue: Math.round(sameDayCancelRevenue * 100) / 100,
        net_revenue_after_same_day_cancel: Math.round(netRevenueAfterSameDayCancel * 100) / 100,
        net_orders_after_same_day_cancel: netOrdersAfterSameDayCancel,
        cancel_rate_same_day: Math.round(cancelRateSameDay * 100) / 100, // Round to 2 decimals
        has_cancelled_at: false, // FALLBACK MODE: No cancelled_at field in schema
      },
    }
  } catch (error) {
    console.error('Unexpected error in getSalesStoryAggregates:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Grouped Sales Orders (Order View)
 * Returns 1 row per order_id with aggregated fields
 * Prevents multi-SKU revenue inflation
 */
export async function getSalesOrdersGrouped(
  filters: ExportFilters & {
    dateBasis?: 'order' | 'paid'
    page: number
    perPage: number
  }
): Promise<{
  success: boolean
  data?: GroupedSalesOrder[]
  count?: number
  error?: string
}> {
  noStore() // Prevent Next.js caching
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const dateBasis = filters.dateBasis || 'order'

    // 2. Build base query to fetch ALL matching lines (we'll group in code)
    let baseQuery = supabase
      .from('sales_orders')
      .select('*')

    // Platform filter (UX v2)
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }

    // Status filter (multi-select, UX v2) - filters by platform_status (Thai values)
    if (filters.status && filters.status.length > 0) {
      baseQuery = baseQuery.in('platform_status', filters.status)
    }

    // Payment status filter (UX v2)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      baseQuery = baseQuery.eq('payment_status', filters.paymentStatus)
    }

    // Date filtering based on date basis (TikTok timestamps)
    // CRITICAL FIX (migration-030): Use COALESCE(created_time, order_date) logic
    if (dateBasis === 'paid') {
      // For paid basis, filter out null paid_time
      baseQuery = baseQuery.not('paid_time', 'is', null)
      if (filters.startDate) {
        baseQuery = baseQuery.gte('paid_time', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('paid_time', endOfDayBangkok.toISOString())
      }
    } else {
      // IMPORTANT: Fetch by order_date (broader) to include created_time=NULL rows
      // Client-side filter will apply COALESCE(created_time, order_date) logic
      if (filters.startDate) {
        baseQuery = baseQuery.gte('order_date', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('order_date', endOfDayBangkok.toISOString())
      }
    }

    // Apply search filter
    if (filters.search && filters.search.trim()) {
      baseQuery = baseQuery.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // Fetch all matching lines
    const { data: rawLines, error: fetchError } = await baseQuery

    if (fetchError) {
      console.error('Error fetching orders for grouping:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawLines || rawLines.length === 0) {
      return { success: true, data: [], count: 0 }
    }

    // CLIENT-SIDE DATE FILTERING WITH COALESCE(created_time, order_date)
    // CRITICAL FIX: Fetch by order_date (broader), filter by effective_date
    const lines = rawLines.filter(line => {
      if (dateBasis === 'paid') {
        // Paid basis already filtered at DB level
        return true
      }

      // Order basis: Use COALESCE(created_time, order_date)
      const effectiveDate = line.created_time || line.order_date

      if (!effectiveDate) {
        console.warn('getSalesOrdersGrouped: Order with no created_time or order_date:', line.order_id)
        return false
      }

      // Convert to Bangkok date for date-only comparison (SAFE: uses Bangkok timezone)
      const bangkokDateStr = toBangkokDateString(new Date(effectiveDate))

      // Apply date filters (startDate/endDate are YYYY-MM-DD)
      if (filters.startDate) {
        if (bangkokDateStr < filters.startDate) return false
      }

      if (filters.endDate) {
        if (bangkokDateStr > filters.endDate) return false
      }

      return true
    })

    if (lines.length === 0) {
      return { success: true, data: [], count: 0 }
    }

    // 3. Group by order_id (use external_order_id as key if available)
    const orderMap = new Map<string, {
      order_id: string
      external_order_id: string | null
      source_platform: string | null
      marketplace: string | null
      platform_status: string | null
      status_group: string | null
      payment_status: string | null
      order_amount: number
      total_units: number
      sku_count: number
      order_date: string
      paid_at: string | null
      shipped_at: string | null
      delivered_at: string | null
      created_by: string | null
      product_names: string[]
      created_time: string | null
      paid_time: string | null
      cancelled_time: string | null
    }>()

    for (const line of lines) {
      const orderId = line.external_order_id || line.order_id

      if (!orderMap.has(orderId)) {
        orderMap.set(orderId, {
          order_id: orderId,
          external_order_id: line.external_order_id,
          source_platform: line.source_platform,
          marketplace: line.marketplace,
          platform_status: line.platform_status,
          status_group: line.status_group,
          payment_status: line.payment_status,
          order_amount: line.total_amount || 0, // Use first line's order amount
          total_units: line.quantity || 0,
          sku_count: 1,
          order_date: line.order_date,
          paid_at: line.paid_at,
          shipped_at: line.shipped_at,
          delivered_at: line.delivered_at,
          created_by: line.created_by,
          product_names: [line.product_name],
          created_time: line.created_time,
          paid_time: line.paid_time,
          cancelled_time: line.cancelled_time,
        })
      } else {
        const existing = orderMap.get(orderId)!
        existing.total_units += line.quantity || 0
        existing.sku_count += 1
        // Order amount should be same across lines (use MAX as safety)
        existing.order_amount = Math.max(existing.order_amount, line.total_amount || 0)
        // Collect product names
        if (!existing.product_names.includes(line.product_name)) {
          existing.product_names.push(line.product_name)
        }
        // Use latest dates (MAX)
        if (line.paid_at && (!existing.paid_at || line.paid_at > existing.paid_at)) {
          existing.paid_at = line.paid_at
        }
        if (line.shipped_at && (!existing.shipped_at || line.shipped_at > existing.shipped_at)) {
          existing.shipped_at = line.shipped_at
        }
        if (line.delivered_at && (!existing.delivered_at || line.delivered_at > existing.delivered_at)) {
          existing.delivered_at = line.delivered_at
        }
        // TikTok timestamps (should be same across lines, use first non-null)
        if (!existing.created_time && line.created_time) {
          existing.created_time = line.created_time
        }
        if (!existing.paid_time && line.paid_time) {
          existing.paid_time = line.paid_time
        }
        if (!existing.cancelled_time && line.cancelled_time) {
          existing.cancelled_time = line.cancelled_time
        }
      }
    }

    // 4. Convert to array and sort by date (descending)
    const groupedOrders: GroupedSalesOrder[] = Array.from(orderMap.values()).map(order => ({
      order_id: order.order_id,
      external_order_id: order.external_order_id,
      source_platform: order.source_platform,
      marketplace: order.marketplace,
      platform_status: order.platform_status,
      status_group: order.status_group,
      payment_status: order.payment_status,
      total_units: order.total_units,
      order_amount: order.order_amount,
      sku_count: order.sku_count,
      order_date: order.order_date,
      paid_at: order.paid_at,
      shipped_at: order.shipped_at,
      delivered_at: order.delivered_at,
      created_by: order.created_by,
      product_names: order.product_names.slice(0, 3).join(', ') + (order.product_names.length > 3 ? '...' : ''),
      created_time: order.created_time,
      paid_time: order.paid_time,
      cancelled_time: order.cancelled_time,
    }))

    // Sort by created_time or paid_time (descending)
    groupedOrders.sort((a, b) => {
      const dateA = dateBasis === 'paid' ? (a.paid_time || a.created_time || a.order_date) : (a.created_time || a.order_date)
      const dateB = dateBasis === 'paid' ? (b.paid_time || b.created_time || b.order_date) : (b.created_time || b.order_date)
      return (dateB || '').localeCompare(dateA || '')
    })

    // 5. Pagination (slice after sorting)
    const totalCount = groupedOrders.length
    const offset = (filters.page - 1) * filters.perPage
    const paginatedOrders = groupedOrders.slice(offset, offset + filters.perPage)

    return {
      success: true,
      data: paginatedOrders,
      count: totalCount,
    }
  } catch (error) {
    console.error('Unexpected error in getSalesOrdersGrouped:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Sales Order Detail (Line Breakdown)
 * Returns all SKU lines for a specific order_id
 */
export async function getSalesOrderDetail(orderId: string): Promise<{
  success: boolean
  data?: SalesOrder[]
  error?: string
}> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Query all lines for this order_id (match by external_order_id OR order_id)
    const { data: lines, error: fetchError } = await supabase
      .from('sales_orders')
      .select('*')
      .or(`external_order_id.eq.${orderId},order_id.eq.${orderId}`)
      .order('product_name', { ascending: true })

    if (fetchError) {
      console.error('Error fetching order detail:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!lines || lines.length === 0) {
      return { success: false, error: 'ไม่พบรายการ order นี้' }
    }

    return { success: true, data: lines }
  } catch (error) {
    console.error('Unexpected error in getSalesOrderDetail:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * =====================================================
 * AUDIT FUNCTIONS - Sales Data Quality & Completeness
 * =====================================================
 */

export interface MultiSkuOrder {
  external_order_id: string
  sku_lines: number
  total_units: number
  gross_amount: number
  created_time: string | null
  paid_time: string | null
}

export interface DuplicateLine {
  external_order_id: string
  sku_id: string | null
  variation: string | null
  dup_rows: number
  latest_created_at: string
}

export interface ImportCoverage {
  total_rows: number
  distinct_orders: number
  rows_with_created_time: number
  rows_with_paid_time: number
  rows_with_cancelled_time: number
  rows_without_created_time: number
}

/**
 * Get Top Multi-SKU Orders (orders with multiple SKU lines)
 */
export async function getMultiSkuOrders(filters: ExportFilters & { dateBasis?: 'order' | 'paid'; limit?: number }): Promise<{
  success: boolean
  data?: MultiSkuOrder[]
  error?: string
}> {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const dateBasis = filters.dateBasis || 'order'
    const limit = filters.limit || 50

    // Build base query
    let baseQuery = supabase
      .from('sales_orders')
      .select('external_order_id, order_id, quantity, total_amount, created_time, paid_time, order_date')

    // Platform filter
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }

    // Date filtering
    // CRITICAL FIX (migration-030): Use order_date for order basis to include created_time=NULL rows
    // Client-side filter will apply COALESCE(created_time, order_date) logic below
    if (dateBasis === 'paid') {
      baseQuery = baseQuery.not('paid_time', 'is', null)
      if (filters.startDate) baseQuery = baseQuery.gte('paid_time', filters.startDate)
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('paid_time', endOfDayBangkok.toISOString())
      }
    } else {
      // Use order_date (broader) to fetch rows with created_time=NULL
      if (filters.startDate) baseQuery = baseQuery.gte('order_date', filters.startDate)
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('order_date', endOfDayBangkok.toISOString())
      }
    }

    const { data: rawLines, error: fetchError } = await baseQuery

    if (fetchError) {
      console.error('Error fetching multi-sku orders:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawLines || rawLines.length === 0) {
      return { success: true, data: [] }
    }

    // CLIENT-SIDE DATE FILTERING WITH COALESCE(created_time, order_date)
    // CRITICAL FIX: Fetch by order_date (broader), filter by effective_date
    const { toZonedTime } = await import('date-fns-tz')
    const lines = rawLines.filter(line => {
      if (dateBasis === 'paid') {
        // Paid basis already filtered at DB level
        return true
      }

      // Order basis: Use COALESCE(created_time, order_date)
      const effectiveDate = line.created_time || line.order_date

      if (!effectiveDate) {
        console.warn('getMultiSkuOrders: Order with no created_time or order_date:', line.order_id)
        return false
      }

      // Convert to Bangkok date for date-only comparison
      const bangkokDate = toZonedTime(new Date(effectiveDate), 'Asia/Bangkok')
      const bangkokDateStr = bangkokDate.toISOString().split('T')[0] // YYYY-MM-DD

      if (filters.startDate && bangkokDateStr < filters.startDate) return false
      if (filters.endDate && bangkokDateStr > filters.endDate) return false

      return true
    })

    if (lines.length === 0) {
      return { success: true, data: [] }
    }

    // Group by external_order_id
    const orderMap = new Map<string, {
      external_order_id: string
      sku_lines: number
      total_units: number
      gross_amount: number
      created_time: string | null
      paid_time: string | null
    }>()

    for (const line of lines) {
      const orderId = line.external_order_id || line.order_id
      const effectiveCreatedTime = line.created_time || line.order_date

      if (!orderMap.has(orderId)) {
        orderMap.set(orderId, {
          external_order_id: orderId,
          sku_lines: 1,
          total_units: line.quantity || 0,
          gross_amount: line.total_amount || 0,
          created_time: effectiveCreatedTime,
          paid_time: line.paid_time,
        })
      } else {
        const existing = orderMap.get(orderId)!
        existing.sku_lines += 1
        existing.total_units += line.quantity || 0
        existing.gross_amount = Math.max(existing.gross_amount, line.total_amount || 0)
      }
    }

    // Filter orders with >1 SKU line and sort by sku_lines desc
    const multiSkuOrders = Array.from(orderMap.values())
      .filter(o => o.sku_lines > 1)
      .sort((a, b) => b.sku_lines - a.sku_lines)
      .slice(0, limit)

    return { success: true, data: multiSkuOrders }
  } catch (error) {
    console.error('Unexpected error in getMultiSkuOrders:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Potential Duplicate Lines (same order + sku + variation appears multiple times)
 */
export async function getDuplicateLines(filters: ExportFilters & { dateBasis?: 'order' | 'paid'; limit?: number }): Promise<{
  success: boolean
  data?: DuplicateLine[]
  error?: string
}> {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const dateBasis = filters.dateBasis || 'order'
    const limit = filters.limit || 100

    // Build base query
    let baseQuery = supabase
      .from('sales_orders')
      .select('external_order_id, order_id, sku_id, metadata, created_at')

    // Platform filter
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }

    // Date filtering (use created_time with fallback to order_date for date range)
    if (filters.startDate || filters.endDate) {
      // We'll filter client-side due to fallback logic complexity
    }

    const { data: rawLines, error: fetchError } = await baseQuery

    if (fetchError) {
      console.error('Error fetching duplicate lines:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawLines || rawLines.length === 0) {
      return { success: true, data: [] }
    }

    // Group by (external_order_id + sku_id + variation)
    const dupKey = (orderId: string, skuId: string | null, variation: string | null) =>
      `${orderId}|${skuId || 'NULL'}|${variation || 'NULL'}`

    const dupMap = new Map<string, {
      external_order_id: string
      sku_id: string | null
      variation: string | null
      dup_rows: number
      latest_created_at: string
    }>()

    for (const line of rawLines) {
      const orderId = line.external_order_id || line.order_id
      const skuId = line.sku_id
      const variation = line.metadata?.variation || null
      const key = dupKey(orderId, skuId, variation)

      if (!dupMap.has(key)) {
        dupMap.set(key, {
          external_order_id: orderId,
          sku_id: skuId,
          variation,
          dup_rows: 1,
          latest_created_at: line.created_at,
        })
      } else {
        const existing = dupMap.get(key)!
        existing.dup_rows += 1
        if (line.created_at > existing.latest_created_at) {
          existing.latest_created_at = line.created_at
        }
      }
    }

    // Filter duplicates (dup_rows > 1) and sort
    const duplicates = Array.from(dupMap.values())
      .filter(d => d.dup_rows > 1)
      .sort((a, b) => b.dup_rows - a.dup_rows)
      .slice(0, limit)

    return { success: true, data: duplicates }
  } catch (error) {
    console.error('Unexpected error in getDuplicateLines:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * =====================================================
 * RECONCILIATION FUNCTION - Debug TikTok Export Mismatch
 * =====================================================
 */

export interface SalesReconciliation {
  sqlDerived: {
    total_lines: number
    distinct_orders: number
    orders_with_null_created_time: number
    orders_with_created_time: number
  }
  missingOrders: Array<{
    external_order_id: string
    order_date: string | null
    created_time: string | null
    reason: string
  }>
}

/**
 * Get Sales Reconciliation Data (TikTok Export vs UI Mismatch Debug)
 * Direct SQL-based query to find root cause of order count difference
 */
export async function getSalesReconciliation(filters: {
  startDate: string
  endDate: string
}): Promise<{
  success: boolean
  sqlDerived?: SalesReconciliation['sqlDerived']
  missingOrders?: SalesReconciliation['missingOrders']
  error?: string
}> {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Query 1: Get total counts with NULL check
    const { data: rawLines, error: fetchError } = await supabase
      .from('sales_orders')
      .select('external_order_id, order_id, created_time, order_date')
      .eq('source_platform', 'tiktok_shop')
      .gte('order_date', filters.startDate)
      .lte('order_date', filters.endDate + 'T23:59:59')

    if (fetchError) {
      console.error('Error fetching reconciliation data:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawLines || rawLines.length === 0) {
      return {
        success: true,
        sqlDerived: {
          total_lines: 0,
          distinct_orders: 0,
          orders_with_null_created_time: 0,
          orders_with_created_time: 0,
        },
        missingOrders: [],
      }
    }

    // Client-side aggregation (for simplicity)
    const { toZonedTime } = await import('date-fns-tz')

    // Filter by Bangkok date
    const filteredLines = rawLines.filter(line => {
      const effectiveDate = line.created_time || line.order_date
      if (!effectiveDate) return false

      const bangkokDate = toZonedTime(new Date(effectiveDate), 'Asia/Bangkok')
      const bangkokDateStr = bangkokDate.toISOString().split('T')[0]

      return bangkokDateStr >= filters.startDate && bangkokDateStr <= filters.endDate
    })

    const totalLines = filteredLines.length
    const distinctOrders = new Set(filteredLines.map(l => l.external_order_id || l.order_id)).size

    // Count orders with NULL created_time
    const ordersWithNullCreatedTime = new Set(
      filteredLines
        .filter(l => !l.created_time)
        .map(l => l.external_order_id || l.order_id)
    ).size

    const ordersWithCreatedTime = distinctOrders - ordersWithNullCreatedTime

    // Get sample missing orders (first 50)
    const missingOrdersMap = new Map<string, {
      external_order_id: string
      order_date: string | null
      created_time: string | null
      reason: string
    }>()

    for (const line of filteredLines) {
      if (!line.created_time) {
        const orderId = line.external_order_id || line.order_id
        if (!missingOrdersMap.has(orderId) && missingOrdersMap.size < 50) {
          missingOrdersMap.set(orderId, {
            external_order_id: orderId,
            order_date: line.order_date,
            created_time: line.created_time,
            reason: 'NULL_CREATED_TIME',
          })
        }
      }
    }

    return {
      success: true,
      sqlDerived: {
        total_lines: totalLines,
        distinct_orders: distinctOrders,
        orders_with_null_created_time: ordersWithNullCreatedTime,
        orders_with_created_time: ordersWithCreatedTime,
      },
      missingOrders: Array.from(missingOrdersMap.values()),
    }
  } catch (error) {
    console.error('Unexpected error in getSalesReconciliation:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Import Coverage Stats (timestamp completeness)
 */
export async function getImportCoverage(filters: ExportFilters & { dateBasis?: 'order' | 'paid' }): Promise<{
  success: boolean
  data?: ImportCoverage
  error?: string
}> {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Build base query
    let baseQuery = supabase
      .from('sales_orders')
      .select('external_order_id, order_id, created_time, paid_time, cancelled_time')

    // Platform filter
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }

    // Date filtering (apply if provided)
    if (filters.startDate || filters.endDate) {
      // Simple query - no date filter for coverage stats (show all imported data)
    }

    const { data: rawLines, error: fetchError } = await baseQuery

    if (fetchError) {
      console.error('Error fetching import coverage:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawLines || rawLines.length === 0) {
      return {
        success: true,
        data: {
          total_rows: 0,
          distinct_orders: 0,
          rows_with_created_time: 0,
          rows_with_paid_time: 0,
          rows_with_cancelled_time: 0,
          rows_without_created_time: 0,
        }
      }
    }

    // Calculate coverage
    const totalRows = rawLines.length
    const distinctOrders = new Set(rawLines.map(l => l.external_order_id || l.order_id)).size
    const rowsWithCreatedTime = rawLines.filter(l => l.created_time).length
    const rowsWithPaidTime = rawLines.filter(l => l.paid_time).length
    const rowsWithCancelledTime = rawLines.filter(l => l.cancelled_time).length
    const rowsWithoutCreatedTime = totalRows - rowsWithCreatedTime

    return {
      success: true,
      data: {
        total_rows: totalRows,
        distinct_orders: distinctOrders,
        rows_with_created_time: rowsWithCreatedTime,
        rows_with_paid_time: rowsWithPaidTime,
        rows_with_cancelled_time: rowsWithCancelledTime,
        rows_without_created_time: rowsWithoutCreatedTime,
      }
    }
  } catch (error) {
    console.error('Unexpected error in getImportCoverage:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * =====================================================
 * ADMIN FUNCTIONS - Reset TikTok OrderSKUList Data
 * =====================================================
 */

export interface ResetTikTokResult {
  dry_run: boolean
  sales_orders_before: number
  import_batches_before: number
  sales_orders_deleted: number
  import_batches_deleted: number
  message: string
}

/**
 * Preview Reset TikTok OrderSKUList (Dry-run)
 * Returns counts of rows that would be deleted without actually deleting
 */
export async function previewResetTikTokOrderSkuList(): Promise<{
  success: boolean
  data?: ResetTikTokResult
  error?: string
}> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Call RPC function with dry_run=true
    const { data, error } = await supabase.rpc('reset_tiktok_ordersku_list', {
      p_dry_run: true,
    })

    if (error) {
      console.error('Error previewing reset:', error)
      return { success: false, error: `เกิดข้อผิดพลาด: ${error.message}` }
    }

    return { success: true, data }
  } catch (error) {
    console.error('Unexpected error in previewResetTikTokOrderSkuList:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Reset TikTok OrderSKUList (Execute Deletion)
 * ADMIN ONLY: Deletes sales_orders and import_batches for TikTok OrderSKUList
 * Requires admin role in user_roles table
 */
export async function resetTikTokOrderSkuList(): Promise<{
  success: boolean
  data?: ResetTikTokResult
  error?: string
}> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Call RPC function with dry_run=false (actual deletion)
    const { data, error } = await supabase.rpc('reset_tiktok_ordersku_list', {
      p_dry_run: false,
    })

    if (error) {
      console.error('Error executing reset:', error)
      // Check if it's an authorization error
      if (error.message.includes('Unauthorized') || error.message.includes('admin')) {
        return { success: false, error: 'ไม่มีสิทธิ์: เฉพาะ Admin เท่านั้นที่สามารถรีเซ็ตข้อมูลได้' }
      }
      return { success: false, error: `เกิดข้อผิดพลาด: ${error.message}` }
    }

    return { success: true, data }
  } catch (error) {
    console.error('Unexpected error in resetTikTokOrderSkuList:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Check if current user is admin
 * Used to conditionally show/hide admin-only UI elements
 */
export async function checkIsAdmin(): Promise<{
  success: boolean
  isAdmin: boolean
  error?: string
}> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, isAdmin: false, error: 'ไม่พบข้อมูลผู้ใช้' }
    }

    // Check user_roles table for admin role
    const { data, error } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single()

    if (error) {
      // If no role found, user is not admin
      if (error.code === 'PGRST116') {
        return { success: true, isAdmin: false }
      }
      console.error('Error checking admin status:', error)
      return { success: false, isAdmin: false, error: error.message }
    }

    return { success: true, isAdmin: data?.role === 'admin' }
  } catch (error) {
    console.error('Unexpected error in checkIsAdmin:', error)
    return {
      success: false,
      isAdmin: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}
