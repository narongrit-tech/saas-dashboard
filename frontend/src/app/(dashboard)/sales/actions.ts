'use server'

import { createClient } from '@/lib/supabase/server'
import { CreateOrderInput, UpdateOrderInput, GroupedSalesOrder, SalesOrder, SalesStoryAggregates, SalesAggregates } from '@/types/sales'
import { toBangkokTime, formatBangkok, getBangkokNow } from '@/lib/bangkok-time'
import { unstable_noStore as noStore } from 'next/cache'
import { toBangkokDateString } from '@/lib/bangkok-date-range'

interface ActionResult {
  success: boolean
  error?: string
  data?: unknown
}

export async function createManualOrder(input: CreateOrderInput): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Validate input
    if (!input.product_name || input.product_name.trim() === '') {
      return { success: false, error: 'กรุณากระอกชื่อสินค้า' }
    }

    if (input.quantity <= 0) {
      return { success: false, error: 'จำนวนต้องมากกว่า 0' }
    }

    if (input.unit_price < 0) {
      return { success: false, error: 'ราคาต่อหน่วยต้องไม่ติดลบ' }
    }

    if (!input.order_date) {
      return { success: false, error: 'กรุณาระบุวันที่สั่งซื้อ' }
    }

    // 3. Calculate total_amount (server-side, cannot be trusted from client)
    // BUSINESS RULE: Total amount must be calculated server-side to prevent tampering
    // BUSINESS RULE: Cancelled orders must have total_amount = 0 (excluded from revenue)
    // FINANCIAL SAFETY: Round to 2 decimal places (currency precision)
    let totalAmount: number

    if (input.status.toLowerCase() === 'cancelled') {
      totalAmount = 0
    } else {
      const rawAmount = input.quantity * input.unit_price
      // Round to 2 decimal places to prevent floating point errors
      totalAmount = Math.round(rawAmount * 100) / 100
    }

    // 4. Generate order_id in format: MAN-YYYYMMDD-XXX
    const orderDate = toBangkokTime(input.order_date)
    const dateStr = formatBangkok(orderDate, 'yyyyMMdd')
    const prefix = `MAN-${dateStr}`

    // Query existing manual orders for today to get counter
    const { data: existingOrders, error: queryError } = await supabase
      .from('sales_orders')
      .select('order_id')
      .ilike('order_id', `${prefix}%`)
      .order('order_id', { ascending: false })
      .limit(1)

    if (queryError) {
      console.error('Error querying existing orders:', queryError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการตรวจสอบ order id' }
    }

    let counter = 1
    if (existingOrders && existingOrders.length > 0) {
      const lastOrderId = existingOrders[0].order_id
      const lastCounter = parseInt(lastOrderId.split('-')[2] || '0')
      counter = lastCounter + 1
    }

    const orderId = `${prefix}-${counter.toString().padStart(3, '0')}`

    // 5. Insert order into database
    // AUDIT SAFETY: Every record must have source and created_by for traceability
    // source = 'manual' | 'csv' | 'api' - identifies data origin
    // created_by = user.id - tracks who created this record
    // created_at = auto-generated by Supabase - timestamp
    // CRITICAL: Manual entries must never be overwritten by imports
    const { data: insertedOrder, error: insertError } = await supabase
      .from('sales_orders')
      .insert({
        order_id: orderId,
        marketplace: input.marketplace,
        product_name: input.product_name.trim(),
        quantity: input.quantity,
        unit_price: input.unit_price,
        total_amount: totalAmount,
        order_date: input.order_date,
        status: input.status,
        source: 'manual', // AUDIT: Mark as manually entered
        created_by: user.id, // AUDIT: Track creator
      })
      .select()
      .single()

    if (insertError) {
      console.error('Error inserting order:', insertError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${insertError.message}` }
    }

    return { success: true, data: insertedOrder }
  } catch (error) {
    console.error('Unexpected error in createManualOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

export async function updateOrder(
  orderId: string,
  input: UpdateOrderInput
): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Validate input
    if (!input.product_name || input.product_name.trim() === '') {
      return { success: false, error: 'กรุณากรอกชื่อสินค้า' }
    }

    if (input.quantity <= 0) {
      return { success: false, error: 'จำนวนต้องมากกว่า 0' }
    }

    if (input.unit_price < 0) {
      return { success: false, error: 'ราคาต่อหน่วยต้องไม่ติดลบ' }
    }

    if (!input.order_date) {
      return { success: false, error: 'กรุณาระบุวันที่สั่งซื้อ' }
    }

    // 3. Check if order exists and belongs to user (RLS will also enforce this)
    const { data: existingOrder, error: fetchError } = await supabase
      .from('sales_orders')
      .select('id, created_by')
      .eq('id', orderId)
      .single()

    if (fetchError || !existingOrder) {
      return { success: false, error: 'ไม่พบรายการ order ที่ต้องการแก้ไข' }
    }

    // Check ownership (defensive - RLS should also prevent this)
    if (existingOrder.created_by !== user.id) {
      return { success: false, error: 'คุณไม่มีสิทธิ์แก้ไข order นี้' }
    }

    // 4. Calculate total_amount (server-side, cannot be trusted from client)
    let totalAmount: number

    if (input.status.toLowerCase() === 'cancelled') {
      totalAmount = 0
    } else {
      const rawAmount = input.quantity * input.unit_price
      totalAmount = Math.round(rawAmount * 100) / 100
    }

    // 5. Update order in database
    const { data: updatedOrder, error: updateError } = await supabase
      .from('sales_orders')
      .update({
        marketplace: input.marketplace,
        product_name: input.product_name.trim(),
        quantity: input.quantity,
        unit_price: input.unit_price,
        total_amount: totalAmount,
        order_date: input.order_date,
        status: input.status,
        updated_at: new Date().toISOString(),
      })
      .eq('id', orderId)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating order:', updateError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${updateError.message}` }
    }

    return { success: true, data: updatedOrder }
  } catch (error) {
    console.error('Unexpected error in updateOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

export async function deleteOrder(orderId: string): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Check if order exists and belongs to user (RLS will also enforce this)
    const { data: existingOrder, error: fetchError } = await supabase
      .from('sales_orders')
      .select('id, created_by, order_id')
      .eq('id', orderId)
      .single()

    if (fetchError || !existingOrder) {
      return { success: false, error: 'ไม่พบรายการ order ที่ต้องการลบ' }
    }

    // Check ownership (defensive - RLS should also prevent this)
    if (existingOrder.created_by !== user.id) {
      return { success: false, error: 'คุณไม่มีสิทธิ์ลบ order นี้' }
    }

    // 3. Hard delete from database
    const { error: deleteError } = await supabase
      .from('sales_orders')
      .delete()
      .eq('id', orderId)

    if (deleteError) {
      console.error('Error deleting order:', deleteError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${deleteError.message}` }
    }

    return { success: true, data: { deletedId: orderId } }
  } catch (error) {
    console.error('Unexpected error in deleteOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

interface ExportFilters {
  marketplace?: string // Legacy (keep for backward compat)
  sourcePlatform?: string // UX v2: tiktok_shop | shopee | etc
  status?: string[] // UX v2: Multi-select status filter
  paymentStatus?: string // UX v2: paid | unpaid
  startDate?: string
  endDate?: string
  search?: string
  view?: 'order' | 'line' // Order View / Line View
  dateBasis?: 'order' | 'paid' // Date filtering basis (TikTok timestamps)
}

interface ExportResult {
  success: boolean
  error?: string
  csv?: string
  filename?: string
}

/**
 * Export Sales Orders to CSV
 * Respects all filters (marketplace, date range, search)
 * Returns CSV content and filename with Bangkok timezone
 *
 * CRITICAL:
 * - If view=order: Export grouped orders (1 row per order_id)
 * - If view=line: Export raw lines (default behavior)
 */
export async function exportSalesOrders(filters: ExportFilters): Promise<ExportResult> {
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const view = filters.view || 'line'
    const dateBasis = filters.dateBasis || 'order'

    // 2. Branch: Order View vs Line View
    if (view === 'order') {
      // Order View Export: Use grouped data (1 row per order)
      const groupedResult = await getSalesOrdersGrouped({
        sourcePlatform: filters.sourcePlatform,
        status: filters.status,
        paymentStatus: filters.paymentStatus,
        startDate: filters.startDate,
        endDate: filters.endDate,
        search: filters.search,
        dateBasis: dateBasis,
        page: 1,
        perPage: 10000, // Export all (with reasonable limit)
      })

      if (!groupedResult.success || !groupedResult.data || groupedResult.data.length === 0) {
        return { success: false, error: 'ไม่พบข้อมูลที่จะ export' }
      }

      // Generate CSV for Order View (Order-level columns)
      const headers = [
        'External Order ID',
        'Created Time',
        'Paid Time',
        'Cancelled Time',
        'Gross Amount',
        'Total Units',
        'SKU Lines',
        'Payment Method',
        'Cancel Same Day Flag',
      ]

      const escapeCSV = (value: string | number | null | undefined): string => {
        if (value === null || value === undefined) return ''
        const str = String(value)
        if (str.includes(',') || str.includes('"') || str.includes('\n')) {
          return `"${str.replace(/"/g, '""')}"`
        }
        return str
      }

      const rows = groupedResult.data.map((order) => {
        // Calculate cancel_same_day_flag (if cancelled_time exists and is same day as created_time)
        let cancelSameDayFlag = 'N'
        if (order.cancelled_time && order.created_time) {
          try {
            const createdDate = new Date(order.created_time).toLocaleDateString('en-CA', { timeZone: 'Asia/Bangkok' })
            const cancelledDate = new Date(order.cancelled_time).toLocaleDateString('en-CA', { timeZone: 'Asia/Bangkok' })
            cancelSameDayFlag = createdDate === cancelledDate ? 'Y' : 'N'
          } catch {
            cancelSameDayFlag = 'N'
          }
        }

        // Extract payment_method from metadata if available (first line's metadata)
        // This is a simplified approach; actual implementation may need to query lines
        const paymentMethod = order.payment_status === 'paid' ? 'Online' : 'COD' // Simplified

        return [
          escapeCSV(order.external_order_id || order.order_id),
          escapeCSV(order.created_time || order.order_date),
          escapeCSV(order.paid_time || order.paid_at || ''),
          escapeCSV(order.cancelled_time || ''),
          escapeCSV(order.order_amount),
          escapeCSV(order.total_units),
          escapeCSV(order.sku_count),
          escapeCSV(paymentMethod),
          escapeCSV(cancelSameDayFlag),
        ].join(',')
      })

      const csvContent = [headers.join(','), ...rows].join('\n')
      const now = getBangkokNow()
      const dateStr = formatBangkok(now, 'yyyyMMdd-HHmmss')
      const filename = `sales-orders-grouped-${dateStr}.csv`

      return {
        success: true,
        csv: csvContent,
        filename,
      }
    }

    // Line View Export: Use raw line data (original behavior)
    // 3. Build query with filters (UX v2 logic)
    // IMPORTANT: Select order_date for fallback in case created_time is NULL
    let query = supabase
      .from('sales_orders')
      .select('*')

    // Order by based on date basis (TikTok timestamps)
    // Note: Rows with NULL created_time will appear last (nullsFirst: false)
    if (dateBasis === 'order') {
      query = query.order('created_time', { ascending: false, nullsFirst: false })
    } else {
      query = query.order('paid_time', { ascending: false, nullsFirst: false })
    }

    // Platform filter (UX v2)
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      query = query.eq('source_platform', filters.sourcePlatform)
    } else if (filters.marketplace && filters.marketplace !== 'All') {
      // Legacy fallback
      query = query.eq('marketplace', filters.marketplace)
    }

    // Status filter (multi-select, UX v2) - filters by platform_status (Thai values)
    if (filters.status && filters.status.length > 0) {
      query = query.in('platform_status', filters.status)
    }

    // Payment status filter (UX v2)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      query = query.eq('payment_status', filters.paymentStatus)
    }

    // Apply date filters based on date basis (TikTok timestamps)
    // CRITICAL FIX (migration-030): Use COALESCE(created_time, order_date) logic
    if (dateBasis === 'order') {
      // Fetch by order_date (broader) to include created_time=NULL rows
      if (filters.startDate) {
        query = query.gte('order_date', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        query = query.lte('order_date', endOfDayBangkok.toISOString())
      }
    } else {
      // For paid basis, filter out null paid_time
      query = query.not('paid_time', 'is', null)
      if (filters.startDate) {
        query = query.gte('paid_time', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        query = query.lte('paid_time', endOfDayBangkok.toISOString())
      }
    }

    // Apply search filter (UX v2 includes external_order_id)
    if (filters.search && filters.search.trim()) {
      query = query.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // No pagination - export all matching records
    // Add reasonable limit to prevent memory issues
    query = query.limit(10000)

    const { data: rawOrders, error: fetchError } = await query

    if (fetchError) {
      console.error('Error fetching orders for export:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawOrders || rawOrders.length === 0) {
      return { success: false, error: 'ไม่พบข้อมูลที่จะ export' }
    }

    // CLIENT-SIDE FILTERING WITH COALESCE(created_time, order_date)
    // CRITICAL FIX: Fetch by order_date (broader), filter by effective_date
    const orders = rawOrders.filter(order => {
      if (dateBasis === 'paid') {
        // Paid basis already filtered at DB level
        return true
      }

      // Order basis: Use COALESCE(created_time, order_date)
      const effectiveDate = order.created_time || order.order_date

      if (!effectiveDate) {
        console.warn('Export: Order with no created_time or order_date:', order.order_id)
        return false
      }

      // Convert to Bangkok date for date-only comparison (SAFE: uses Bangkok timezone)
      const bangkokDateStr = toBangkokDateString(new Date(effectiveDate))

      if (filters.startDate) {
        if (bangkokDateStr < filters.startDate) return false
      }

      if (filters.endDate) {
        if (bangkokDateStr > filters.endDate) return false
      }

      return true
    })

    if (orders.length === 0) {
      return { success: false, error: 'ไม่พบข้อมูลที่จะ export' }
    }

    // 3. Generate CSV content (UX v2 with platform status & payment)
    // CSV Headers (English for Excel compatibility)
    const headers = [
      'Order ID',
      'External Order ID',
      'Platform',
      'Product Name',
      'Quantity',
      'Unit Price',
      'Total Amount',
      'Internal Status',
      'Platform Status',
      'Status Group',
      'Payment Status',
      'Paid Date',
      'Order Date',
      'Created At',
    ]

    // Escape CSV field (handle commas, quotes, newlines)
    const escapeCSV = (value: string | number | null | undefined): string => {
      if (value === null || value === undefined) return ''
      const str = String(value)
      // If contains comma, quote, or newline, wrap in quotes and escape quotes
      if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return `"${str.replace(/"/g, '""')}"`
      }
      return str
    }

    // Build CSV rows (UX v2 with platform status & payment)
    const rows = orders.map((order) => {
      return [
        escapeCSV(order.order_id),
        escapeCSV(order.external_order_id || ''),
        escapeCSV(order.source_platform || order.marketplace),
        escapeCSV(order.product_name),
        escapeCSV(order.quantity),
        escapeCSV(order.unit_price),
        escapeCSV(order.total_amount),
        escapeCSV(order.status),
        escapeCSV(order.platform_status || ''),
        escapeCSV(order.status_group || ''),
        escapeCSV(order.payment_status || ''),
        escapeCSV(order.paid_at || ''),
        escapeCSV(order.order_date),
        escapeCSV(order.created_at),
      ].join(',')
    })

    // Combine headers and rows
    const csvContent = [headers.join(','), ...rows].join('\n')

    // 4. Generate filename with Bangkok timezone
    const now = getBangkokNow()
    const dateStr = formatBangkok(now, 'yyyyMMdd-HHmmss')
    const filename = `sales-orders-${dateStr}.csv`

    return {
      success: true,
      csv: csvContent,
      filename,
    }
  } catch (error) {
    console.error('Unexpected error in exportSalesOrders:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Sales Aggregates (Summary Metrics)
 * Computes summary metrics for Sales Orders page
 * Uses SAME filters as getSalesOrders to prevent drift
 *
 * CRITICAL:
 * - Uses order-level aggregation (1 row per order_id)
 * - Date filtering uses paid_at or order_date based on dateBasis param
 */
/**
 * Get Sales Aggregates with TikTok Business Timestamp Semantics
 *
 * Key Concepts:
 * - Uses TikTok business timestamps (created_time, paid_time, cancelled_time) NOT DB timestamps
 * - dateBasis: "order" filters by created_time, "paid" filters by paid_time (with IS NOT NULL check)
 * - Same-day cancel: DATE(cancelled_time) = DATE(created_time) in Bangkok timezone
 * - Order-level aggregation: Groups by external_order_id, uses MAX(total_amount) per order (not SUM across lines)
 * - Import completeness verification: compares orders_distinct vs lines_total
 *
 * @param filters - Export filters with date range, platform, status, and dateBasis
 * @returns SalesAggregates with revenue_net/gross, orders_net/gross, cancel rates, units, AOV, completeness metrics
 */
// Do not compute totals from rows (pagination-safe)
export async function getSalesAggregates(filters: ExportFilters & { dateBasis?: 'order' | 'paid' }): Promise<{
  success: boolean
  data?: SalesAggregates
  error?: string
}> {
  noStore() // Prevent Next.js caching
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const dateBasis = filters.dateBasis || 'order' // Default to created_time-based

    // 2. Prepare parameters for RPC call
    const params = {
      p_user_id: user.id,
      p_start_date: filters.startDate || '1970-01-01',
      p_end_date: filters.endDate || '2099-12-31',
      p_date_basis: dateBasis,
      p_source_platform: filters.sourcePlatform && filters.sourcePlatform !== 'all'
        ? filters.sourcePlatform
        : null,
      p_status: filters.status && filters.status.length > 0
        ? filters.status
        : null,
      p_payment_status: filters.paymentStatus && filters.paymentStatus !== 'all'
        ? filters.paymentStatus
        : null,
    }

    // 3. Call RPC function for DB-level aggregation
    const { data: rpcData, error: rpcError } = await supabase.rpc('get_sales_aggregates', params)

    if (rpcError) {
      console.error('Error calling get_sales_aggregates RPC:', rpcError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    // 4. Extract result (RPC returns single row)
    const result = Array.isArray(rpcData) && rpcData.length > 0 ? rpcData[0] : null

    if (!result) {
      // Return zero aggregates if no data
      return {
        success: true,
        data: {
          revenue_gross: 0,
          revenue_net: 0,
          cancelled_same_day_amount: 0,
          cancel_rate_revenue_pct: 0,
          orders_gross: 0,
          orders_net: 0,
          cancelled_same_day_orders: 0,
          cancel_rate_orders_pct: 0,
          total_units: 0,
          aov_net: 0,
          orders_distinct: 0,
          lines_total: 0,
          total_lines: 0,
          total_orders: 0,
          lines_per_order: 0,
        },
      }
    }

    // 5. Transform result to match SalesAggregates interface
    const linesPerOrder = result.orders_distinct > 0
      ? result.lines_total / result.orders_distinct
      : 0

    return {
      success: true,
      data: {
        revenue_gross: result.revenue_gross,
        revenue_net: result.revenue_net,
        cancelled_same_day_amount: result.cancelled_same_day_amount,
        cancel_rate_revenue_pct: result.cancel_rate_revenue_pct,
        orders_gross: result.orders_gross,
        orders_net: result.orders_net,
        cancelled_same_day_orders: result.cancelled_same_day_orders,
        cancel_rate_orders_pct: result.cancel_rate_orders_pct,
        total_units: result.total_units,
        aov_net: result.aov_net,
        orders_distinct: result.orders_distinct,
        lines_total: result.lines_total,
        // UI-friendly aliases
        total_lines: result.lines_total,
        total_orders: result.orders_distinct,
        lines_per_order: Math.round(linesPerOrder * 100) / 100,
      },
    }
  } catch (error) {
    console.error('Unexpected error in getSalesAggregates:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get TikTok-Style Sales Aggregates
 * Uses created_at-based filtering (matches TikTok Seller Center semantics)
 * For reference/comparison purposes only - NOT used for business P&L
 *
 * CRITICAL:
 * - Always uses created_at for date filtering (ignores dateBasis)
 * - Counts DISTINCT orders created in date range
 * - Identifies cancelled orders within that created date range
 */
export interface TikTokStyleAggregates {
  total_created_orders: number // DISTINCT order count by created_at
  cancelled_created_orders: number // DISTINCT cancelled order count by created_at
  cancel_rate: number // cancelled / total (0-100%)
}

// Do not compute totals from rows (pagination-safe)
export async function getSalesAggregatesTikTokLike(filters: ExportFilters): Promise<{
  success: boolean
  data?: TikTokStyleAggregates
  error?: string
}> {
  noStore() // Prevent Next.js caching
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Prepare parameters for RPC call
    const params = {
      p_user_id: user.id,
      p_start_date: filters.startDate || '1970-01-01',
      p_end_date: filters.endDate || '2099-12-31',
      p_source_platform: filters.sourcePlatform && filters.sourcePlatform !== 'all'
        ? filters.sourcePlatform
        : null,
      p_status: filters.status && filters.status.length > 0
        ? filters.status
        : null,
      p_payment_status: filters.paymentStatus && filters.paymentStatus !== 'all'
        ? filters.paymentStatus
        : null,
    }

    // 3. Call RPC function for DB-level aggregation
    const { data: rpcData, error: rpcError } = await supabase.rpc('get_sales_aggregates_tiktok_like', params)

    if (rpcError) {
      console.error('Error calling get_sales_aggregates_tiktok_like RPC:', rpcError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    // 4. Extract result (RPC returns single row)
    const result = Array.isArray(rpcData) && rpcData.length > 0 ? rpcData[0] : null

    if (!result) {
      // Return zero aggregates if no data
      return {
        success: true,
        data: {
          total_created_orders: 0,
          cancelled_created_orders: 0,
          cancel_rate: 0,
        },
      }
    }

    // 5. Return transformed result
    return {
      success: true,
      data: {
        total_created_orders: result.total_created_orders,
        cancelled_created_orders: result.cancelled_created_orders,
        cancel_rate: result.cancel_rate,
      },
    }
  } catch (error) {
    console.error('Unexpected error in getSalesAggregatesTikTokLike:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Sales Story Aggregates (Created-based, Same-day Cancel)
 * For 60/40 Story Panel: Net vs Gross + Same-day Cancel %
 *
 * CRITICAL:
 * - Always uses created_at for date filtering (ignores dateBasis)
 * - Same-day cancel: Orders cancelled on same calendar day as created
 * - Fallback mode (no cancelled_at field): All cancelled orders in range
 * - Must use order-level aggregation: MAX(total_amount) per order_id
 */
// Do not compute totals from rows (pagination-safe)
export async function getSalesStoryAggregates(filters: ExportFilters): Promise<{
  success: boolean
  data?: SalesStoryAggregates
  error?: string
}> {
  noStore() // Prevent Next.js caching
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Prepare parameters for RPC call
    const params = {
      p_user_id: user.id,
      p_start_date: filters.startDate || '1970-01-01',
      p_end_date: filters.endDate || '2099-12-31',
      p_source_platform: filters.sourcePlatform && filters.sourcePlatform !== 'all'
        ? filters.sourcePlatform
        : null,
      p_status: filters.status && filters.status.length > 0
        ? filters.status
        : null,
      p_payment_status: filters.paymentStatus && filters.paymentStatus !== 'all'
        ? filters.paymentStatus
        : null,
    }

    // 3. Call RPC function for DB-level aggregation
    const { data: rpcData, error: rpcError } = await supabase.rpc('get_sales_story_aggregates', params)

    if (rpcError) {
      console.error('Error calling get_sales_story_aggregates RPC:', rpcError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    // 4. Extract result (RPC returns single row)
    const result = Array.isArray(rpcData) && rpcData.length > 0 ? rpcData[0] : null

    if (!result) {
      // Return zero aggregates if no data
      return {
        success: true,
        data: {
          gross_revenue_created: 0,
          total_created_orders: 0,
          same_day_cancel_orders: 0,
          same_day_cancel_revenue: 0,
          net_revenue_after_same_day_cancel: 0,
          net_orders_after_same_day_cancel: 0,
          cancel_rate_same_day: 0,
          has_cancelled_at: false,
        },
      }
    }

    // 5. Return transformed result
    return {
      success: true,
      data: {
        gross_revenue_created: result.gross_revenue_created,
        total_created_orders: result.total_created_orders,
        same_day_cancel_orders: result.same_day_cancel_orders,
        same_day_cancel_revenue: result.same_day_cancel_revenue,
        net_revenue_after_same_day_cancel: result.net_revenue_after_same_day_cancel,
        net_orders_after_same_day_cancel: result.net_orders_after_same_day_cancel,
        cancel_rate_same_day: result.cancel_rate_same_day,
        has_cancelled_at: result.has_cancelled_at,
      },
    }
  } catch (error) {
    console.error('Unexpected error in getSalesStoryAggregates:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Grouped Sales Orders (Order View)
 * Returns 1 row per order_id with aggregated fields
 * Prevents multi-SKU revenue inflation
 */
export async function getSalesOrdersGrouped(
  filters: ExportFilters & {
    dateBasis?: 'order' | 'paid'
    page: number
    perPage: number
  }
): Promise<{
  success: boolean
  data?: GroupedSalesOrder[]
  count?: number
  error?: string
}> {
  noStore() // Prevent Next.js caching
  const startedAt = Date.now()
  const dateBasisForLog = filters.dateBasis || 'order'
  let pageFetches = 0
  let rawLineCount = 0
  let filteredLineCount = 0
  let groupedCount = 0
  let requestError: string | null = null

  console.log('[Sales][getSalesOrdersGrouped] start', {
    dateBasis: dateBasisForLog,
    page: filters.page,
    perPage: filters.perPage,
    sourcePlatform: filters.sourcePlatform || 'all',
    statusCount: filters.status?.length || 0,
    paymentStatus: filters.paymentStatus || 'all',
    startDate: filters.startDate || null,
    endDate: filters.endDate || null,
    hasSearch: Boolean(filters.search && filters.search.trim()),
  })

  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      requestError = authError?.message || 'unauthenticated'
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const dateBasis = filters.dateBasis || 'order'

    // 2. Build base query to fetch ALL matching lines (we'll group in code)
    let baseQuery = supabase
      .from('sales_orders')
      .select('*')

    // Platform filter (UX v2)
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }

    // Status filter (multi-select, UX v2) - filters by platform_status (Thai values)
    if (filters.status && filters.status.length > 0) {
      baseQuery = baseQuery.in('platform_status', filters.status)
    }

    // Payment status filter (UX v2)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      baseQuery = baseQuery.eq('payment_status', filters.paymentStatus)
    }

    // Date filtering based on date basis (TikTok timestamps)
    // CRITICAL FIX (migration-030): Use COALESCE(created_time, order_date) logic
    if (dateBasis === 'paid') {
      // For paid basis, filter out null paid_time
      baseQuery = baseQuery.not('paid_time', 'is', null)
      if (filters.startDate) {
        baseQuery = baseQuery.gte('paid_time', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('paid_time', endOfDayBangkok.toISOString())
      }
    } else {
      // IMPORTANT: Fetch by order_date (broader) to include created_time=NULL rows
      // Client-side filter will apply COALESCE(created_time, order_date) logic
      if (filters.startDate) {
        baseQuery = baseQuery.gte('order_date', filters.startDate)
      }
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('order_date', endOfDayBangkok.toISOString())
      }
    }

    // Apply search filter
    if (filters.search && filters.search.trim()) {
      baseQuery = baseQuery.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // Fetch all matching lines with pagination to bypass 1000 row limit
    let rawLines: any[] = []
    let from = 0
    const pageSize = 1000
    let hasMore = true

    while (hasMore) {
      const { data, error } = await baseQuery.range(from, from + pageSize - 1)
      pageFetches += 1

      if (error) {
        console.error('Error fetching orders for grouping:', error)
        requestError = error.message
        return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
      }

      if (data && data.length > 0) {
        rawLines = rawLines.concat(data)
        hasMore = data.length === pageSize
        from += pageSize
      } else {
        hasMore = false
      }
    }

    rawLineCount = rawLines.length
    if (!rawLines || rawLines.length === 0) {
      return { success: true, data: [], count: 0 }
    }

    // CLIENT-SIDE DATE FILTERING WITH COALESCE(created_time, order_date)
    // CRITICAL FIX: Fetch by order_date (broader), filter by effective_date
    const lines = rawLines.filter(line => {
      if (dateBasis === 'paid') {
        // Paid basis already filtered at DB level
        return true
      }

      // Order basis: Use COALESCE(created_time, order_date)
      const effectiveDate = line.created_time || line.order_date

      if (!effectiveDate) {
        console.warn('getSalesOrdersGrouped: Order with no created_time or order_date:', line.order_id)
        return false
      }

      // Convert to Bangkok date for date-only comparison (SAFE: uses Bangkok timezone)
      const bangkokDateStr = toBangkokDateString(new Date(effectiveDate))

      // Apply date filters (startDate/endDate are YYYY-MM-DD)
      if (filters.startDate) {
        if (bangkokDateStr < filters.startDate) return false
      }

      if (filters.endDate) {
        if (bangkokDateStr > filters.endDate) return false
      }

      return true
    })

    filteredLineCount = lines.length
    if (lines.length === 0) {
      return { success: true, data: [], count: 0 }
    }

    // 3. Group by order_id (use external_order_id as key if available)
    const orderMap = new Map<string, {
      order_id: string
      external_order_id: string | null
      source_platform: string | null
      marketplace: string | null
      platform_status: string | null
      status_group: string | null
      payment_status: string | null
      order_amount: number
      total_units: number
      sku_count: number
      order_date: string
      paid_at: string | null
      shipped_at: string | null
      delivered_at: string | null
      created_by: string | null
      product_names: string[]
      created_time: string | null
      paid_time: string | null
      cancelled_time: string | null
    }>()

    for (const line of lines) {
      const orderId = line.external_order_id || line.order_id

      if (!orderMap.has(orderId)) {
        orderMap.set(orderId, {
          order_id: orderId,
          external_order_id: line.external_order_id,
          source_platform: line.source_platform,
          marketplace: line.marketplace,
          platform_status: line.platform_status,
          status_group: line.status_group,
          payment_status: line.payment_status,
          order_amount: line.total_amount || 0, // Use first line's order amount
          total_units: line.quantity || 0,
          sku_count: 1,
          order_date: line.order_date,
          paid_at: line.paid_at,
          shipped_at: line.shipped_at,
          delivered_at: line.delivered_at,
          created_by: line.created_by,
          product_names: [line.product_name],
          created_time: line.created_time,
          paid_time: line.paid_time,
          cancelled_time: line.cancelled_time,
        })
      } else {
        const existing = orderMap.get(orderId)!
        existing.total_units += line.quantity || 0
        existing.sku_count += 1
        // Order amount should be same across lines (use MAX as safety)
        existing.order_amount = Math.max(existing.order_amount, line.total_amount || 0)
        // Collect product names
        if (!existing.product_names.includes(line.product_name)) {
          existing.product_names.push(line.product_name)
        }
        // Use latest dates (MAX)
        if (line.paid_at && (!existing.paid_at || line.paid_at > existing.paid_at)) {
          existing.paid_at = line.paid_at
        }
        if (line.shipped_at && (!existing.shipped_at || line.shipped_at > existing.shipped_at)) {
          existing.shipped_at = line.shipped_at
        }
        if (line.delivered_at && (!existing.delivered_at || line.delivered_at > existing.delivered_at)) {
          existing.delivered_at = line.delivered_at
        }
        // TikTok timestamps (should be same across lines, use first non-null)
        if (!existing.created_time && line.created_time) {
          existing.created_time = line.created_time
        }
        if (!existing.paid_time && line.paid_time) {
          existing.paid_time = line.paid_time
        }
        if (!existing.cancelled_time && line.cancelled_time) {
          existing.cancelled_time = line.cancelled_time
        }
      }
    }

    // 4. Convert to array and sort by date (descending)
    const groupedOrders: GroupedSalesOrder[] = Array.from(orderMap.values()).map(order => ({
      order_id: order.order_id,
      external_order_id: order.external_order_id,
      source_platform: order.source_platform,
      marketplace: order.marketplace,
      platform_status: order.platform_status,
      status_group: order.status_group,
      payment_status: order.payment_status,
      total_units: order.total_units,
      order_amount: order.order_amount,
      sku_count: order.sku_count,
      order_date: order.order_date,
      paid_at: order.paid_at,
      shipped_at: order.shipped_at,
      delivered_at: order.delivered_at,
      created_by: order.created_by,
      product_names: order.product_names.slice(0, 3).join(', ') + (order.product_names.length > 3 ? '...' : ''),
      created_time: order.created_time,
      paid_time: order.paid_time,
      cancelled_time: order.cancelled_time,
    }))

    // Sort by created_time or paid_time (descending)
    groupedOrders.sort((a, b) => {
      const dateA = dateBasis === 'paid' ? (a.paid_time || a.created_time || a.order_date) : (a.created_time || a.order_date)
      const dateB = dateBasis === 'paid' ? (b.paid_time || b.created_time || b.order_date) : (b.created_time || b.order_date)
      return (dateB || '').localeCompare(dateA || '')
    })

    // 5. Pagination (slice after sorting)
    const totalCount = groupedOrders.length
    groupedCount = totalCount
    const offset = (filters.page - 1) * filters.perPage
    const paginatedOrders = groupedOrders.slice(offset, offset + filters.perPage)

    return {
      success: true,
      data: paginatedOrders,
      count: totalCount,
    }
  } catch (error) {
    console.error('Unexpected error in getSalesOrdersGrouped:', error)
    requestError = error instanceof Error ? error.message : 'unknown error'
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  } finally {
    console.log('[Sales][getSalesOrdersGrouped] end', {
      durationMs: Date.now() - startedAt,
      dateBasis: dateBasisForLog,
      pageFetches,
      rawLineCount,
      filteredLineCount,
      groupedCount,
      error: requestError,
    })
  }
}

/**
 * Get Sales Order Detail (Line Breakdown)
 * Returns all SKU lines for a specific order_id
 */
export async function getSalesOrderDetail(orderId: string): Promise<{
  success: boolean
  data?: SalesOrder[]
  error?: string
}> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Query all lines for this order_id (match by external_order_id OR order_id)
    const { data: lines, error: fetchError } = await supabase
      .from('sales_orders')
      .select('*')
      .or(`external_order_id.eq.${orderId},order_id.eq.${orderId}`)
      .order('product_name', { ascending: true })

    if (fetchError) {
      console.error('Error fetching order detail:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!lines || lines.length === 0) {
      return { success: false, error: 'ไม่พบรายการ order นี้' }
    }

    return { success: true, data: lines }
  } catch (error) {
    console.error('Unexpected error in getSalesOrderDetail:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * =====================================================
 * AUDIT FUNCTIONS - Sales Data Quality & Completeness
 * =====================================================
 */

export interface MultiSkuOrder {
  external_order_id: string
  sku_lines: number
  total_units: number
  gross_amount: number
  created_time: string | null
  paid_time: string | null
}

export interface DuplicateLine {
  external_order_id: string
  sku_id: string | null
  variation: string | null
  dup_rows: number
  latest_created_at: string
}

export interface ImportCoverage {
  total_rows: number
  distinct_orders: number
  rows_with_created_time: number
  rows_with_paid_time: number
  rows_with_cancelled_time: number
  rows_without_created_time: number
}

/**
 * Get Top Multi-SKU Orders (orders with multiple SKU lines)
 */
export async function getMultiSkuOrders(filters: ExportFilters & { dateBasis?: 'order' | 'paid'; limit?: number }): Promise<{
  success: boolean
  data?: MultiSkuOrder[]
  error?: string
}> {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const dateBasis = filters.dateBasis || 'order'
    const limit = filters.limit || 50

    // Build base query
    let baseQuery = supabase
      .from('sales_orders')
      .select('external_order_id, order_id, quantity, total_amount, created_time, paid_time, order_date')

    // Platform filter
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }

    // Date filtering
    // CRITICAL FIX (migration-030): Use order_date for order basis to include created_time=NULL rows
    // Client-side filter will apply COALESCE(created_time, order_date) logic below
    if (dateBasis === 'paid') {
      baseQuery = baseQuery.not('paid_time', 'is', null)
      if (filters.startDate) baseQuery = baseQuery.gte('paid_time', filters.startDate)
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('paid_time', endOfDayBangkok.toISOString())
      }
    } else {
      // Use order_date (broader) to fetch rows with created_time=NULL
      if (filters.startDate) baseQuery = baseQuery.gte('order_date', filters.startDate)
      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        baseQuery = baseQuery.lte('order_date', endOfDayBangkok.toISOString())
      }
    }

    // Fetch all matching lines with pagination to bypass 1000 row limit
    let rawLines: any[] = []
    let from = 0
    const pageSize = 1000
    let hasMore = true

    while (hasMore) {
      const { data, error } = await baseQuery.range(from, from + pageSize - 1)

      if (error) {
        console.error('Error fetching multi-sku orders:', error)
        return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
      }

      if (data && data.length > 0) {
        rawLines = rawLines.concat(data)
        hasMore = data.length === pageSize
        from += pageSize
      } else {
        hasMore = false
      }
    }

    if (!rawLines || rawLines.length === 0) {
      return { success: true, data: [] }
    }

    // CLIENT-SIDE DATE FILTERING WITH COALESCE(created_time, order_date)
    // CRITICAL FIX: Fetch by order_date (broader), filter by effective_date
    const { toZonedTime } = await import('date-fns-tz')
    const lines = rawLines.filter(line => {
      if (dateBasis === 'paid') {
        // Paid basis already filtered at DB level
        return true
      }

      // Order basis: Use COALESCE(created_time, order_date)
      const effectiveDate = line.created_time || line.order_date

      if (!effectiveDate) {
        console.warn('getMultiSkuOrders: Order with no created_time or order_date:', line.order_id)
        return false
      }

      // Convert to Bangkok date for date-only comparison
      const bangkokDate = toZonedTime(new Date(effectiveDate), 'Asia/Bangkok')
      const bangkokDateStr = bangkokDate.toISOString().split('T')[0] // YYYY-MM-DD

      if (filters.startDate && bangkokDateStr < filters.startDate) return false
      if (filters.endDate && bangkokDateStr > filters.endDate) return false

      return true
    })

    if (lines.length === 0) {
      return { success: true, data: [] }
    }

    // Group by external_order_id
    const orderMap = new Map<string, {
      external_order_id: string
      sku_lines: number
      total_units: number
      gross_amount: number
      created_time: string | null
      paid_time: string | null
    }>()

    for (const line of lines) {
      const orderId = line.external_order_id || line.order_id
      const effectiveCreatedTime = line.created_time || line.order_date

      if (!orderMap.has(orderId)) {
        orderMap.set(orderId, {
          external_order_id: orderId,
          sku_lines: 1,
          total_units: line.quantity || 0,
          gross_amount: line.total_amount || 0,
          created_time: effectiveCreatedTime,
          paid_time: line.paid_time,
        })
      } else {
        const existing = orderMap.get(orderId)!
        existing.sku_lines += 1
        existing.total_units += line.quantity || 0
        existing.gross_amount = Math.max(existing.gross_amount, line.total_amount || 0)
      }
    }

    // Filter orders with >1 SKU line and sort by sku_lines desc
    const multiSkuOrders = Array.from(orderMap.values())
      .filter(o => o.sku_lines > 1)
      .sort((a, b) => b.sku_lines - a.sku_lines)
      .slice(0, limit)

    return { success: true, data: multiSkuOrders }
  } catch (error) {
    console.error('Unexpected error in getMultiSkuOrders:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Potential Duplicate Lines (same order + sku + variation appears multiple times)
 */
export async function getDuplicateLines(filters: ExportFilters & { dateBasis?: 'order' | 'paid'; limit?: number }): Promise<{
  success: boolean
  data?: DuplicateLine[]
  error?: string
}> {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    const dateBasis = filters.dateBasis || 'order'
    const limit = filters.limit || 100

    // Build base query
    let baseQuery = supabase
      .from('sales_orders')
      .select('external_order_id, order_id, sku_id, metadata, created_at')

    // Platform filter
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }

    // Date filtering (use created_time with fallback to order_date for date range)
    if (filters.startDate || filters.endDate) {
      // We'll filter client-side due to fallback logic complexity
    }

    // Fetch all matching lines with pagination to bypass 1000 row limit
    let rawLines: any[] = []
    let from = 0
    const pageSize = 1000
    let hasMore = true

    while (hasMore) {
      const { data, error } = await baseQuery.range(from, from + pageSize - 1)

      if (error) {
        console.error('Error fetching duplicate lines:', error)
        return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
      }

      if (data && data.length > 0) {
        rawLines = rawLines.concat(data)
        hasMore = data.length === pageSize
        from += pageSize
      } else {
        hasMore = false
      }
    }

    if (!rawLines || rawLines.length === 0) {
      return { success: true, data: [] }
    }

    // Group by (external_order_id + sku_id + variation)
    const dupKey = (orderId: string, skuId: string | null, variation: string | null) =>
      `${orderId}|${skuId || 'NULL'}|${variation || 'NULL'}`

    const dupMap = new Map<string, {
      external_order_id: string
      sku_id: string | null
      variation: string | null
      dup_rows: number
      latest_created_at: string
    }>()

    for (const line of rawLines) {
      const orderId = line.external_order_id || line.order_id
      const skuId = line.sku_id
      const variation = line.metadata?.variation || null
      const key = dupKey(orderId, skuId, variation)

      if (!dupMap.has(key)) {
        dupMap.set(key, {
          external_order_id: orderId,
          sku_id: skuId,
          variation,
          dup_rows: 1,
          latest_created_at: line.created_at,
        })
      } else {
        const existing = dupMap.get(key)!
        existing.dup_rows += 1
        if (line.created_at > existing.latest_created_at) {
          existing.latest_created_at = line.created_at
        }
      }
    }

    // Filter duplicates (dup_rows > 1) and sort
    const duplicates = Array.from(dupMap.values())
      .filter(d => d.dup_rows > 1)
      .sort((a, b) => b.dup_rows - a.dup_rows)
      .slice(0, limit)

    return { success: true, data: duplicates }
  } catch (error) {
    console.error('Unexpected error in getDuplicateLines:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * =====================================================
 * RECONCILIATION FUNCTION - Debug TikTok Export Mismatch
 * =====================================================
 */

export interface SalesReconciliation {
  sqlDerived: {
    total_lines: number
    distinct_orders: number
    orders_with_null_created_time: number
    orders_with_created_time: number
  }
  missingOrders: Array<{
    external_order_id: string
    order_date: string | null
    created_time: string | null
    reason: string
  }>
}

/**
 * Get Sales Reconciliation Data (TikTok Export vs UI Mismatch Debug)
 * Direct SQL-based query to find root cause of order count difference
 */
export async function getSalesReconciliation(filters: {
  startDate: string
  endDate: string
}): Promise<{
  success: boolean
  sqlDerived?: SalesReconciliation['sqlDerived']
  missingOrders?: SalesReconciliation['missingOrders']
  error?: string
}> {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Query 1: Get total counts with NULL check
    const { data: rawLines, error: fetchError } = await supabase
      .from('sales_orders')
      .select('external_order_id, order_id, created_time, order_date')
      .eq('source_platform', 'tiktok_shop')
      .gte('order_date', filters.startDate)
      .lte('order_date', filters.endDate + 'T23:59:59')

    if (fetchError) {
      console.error('Error fetching reconciliation data:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!rawLines || rawLines.length === 0) {
      return {
        success: true,
        sqlDerived: {
          total_lines: 0,
          distinct_orders: 0,
          orders_with_null_created_time: 0,
          orders_with_created_time: 0,
        },
        missingOrders: [],
      }
    }

    // Client-side aggregation (for simplicity)
    const { toZonedTime } = await import('date-fns-tz')

    // Filter by Bangkok date
    const filteredLines = rawLines.filter(line => {
      const effectiveDate = line.created_time || line.order_date
      if (!effectiveDate) return false

      const bangkokDate = toZonedTime(new Date(effectiveDate), 'Asia/Bangkok')
      const bangkokDateStr = bangkokDate.toISOString().split('T')[0]

      return bangkokDateStr >= filters.startDate && bangkokDateStr <= filters.endDate
    })

    const totalLines = filteredLines.length
    const distinctOrders = new Set(filteredLines.map(l => l.external_order_id || l.order_id)).size

    // Count orders with NULL created_time
    const ordersWithNullCreatedTime = new Set(
      filteredLines
        .filter(l => !l.created_time)
        .map(l => l.external_order_id || l.order_id)
    ).size

    const ordersWithCreatedTime = distinctOrders - ordersWithNullCreatedTime

    // Get sample missing orders (first 50)
    const missingOrdersMap = new Map<string, {
      external_order_id: string
      order_date: string | null
      created_time: string | null
      reason: string
    }>()

    for (const line of filteredLines) {
      if (!line.created_time) {
        const orderId = line.external_order_id || line.order_id
        if (!missingOrdersMap.has(orderId) && missingOrdersMap.size < 50) {
          missingOrdersMap.set(orderId, {
            external_order_id: orderId,
            order_date: line.order_date,
            created_time: line.created_time,
            reason: 'NULL_CREATED_TIME',
          })
        }
      }
    }

    return {
      success: true,
      sqlDerived: {
        total_lines: totalLines,
        distinct_orders: distinctOrders,
        orders_with_null_created_time: ordersWithNullCreatedTime,
        orders_with_created_time: ordersWithCreatedTime,
      },
      missingOrders: Array.from(missingOrdersMap.values()),
    }
  } catch (error) {
    console.error('Unexpected error in getSalesReconciliation:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Import Coverage Stats (timestamp completeness)
 */
export async function getImportCoverage(filters: ExportFilters & { dateBasis?: 'order' | 'paid' }): Promise<{
  success: boolean
  data?: ImportCoverage
  error?: string
}> {
  try {
    const supabase = createClient()
    const { data: { user }, error: authError } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Build base query
    let baseQuery = supabase
      .from('sales_orders')
      .select('external_order_id, order_id, created_time, paid_time, cancelled_time')

    // Platform filter
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }

    // Date filtering (apply if provided)
    if (filters.startDate || filters.endDate) {
      // Simple query - no date filter for coverage stats (show all imported data)
    }

    // Fetch all matching lines with pagination to bypass 1000 row limit
    let rawLines: any[] = []
    let from = 0
    const pageSize = 1000
    let hasMore = true

    while (hasMore) {
      const { data, error } = await baseQuery.range(from, from + pageSize - 1)

      if (error) {
        console.error('Error fetching import coverage:', error)
        return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
      }

      if (data && data.length > 0) {
        rawLines = rawLines.concat(data)
        hasMore = data.length === pageSize
        from += pageSize
      } else {
        hasMore = false
      }
    }

    if (!rawLines || rawLines.length === 0) {
      return {
        success: true,
        data: {
          total_rows: 0,
          distinct_orders: 0,
          rows_with_created_time: 0,
          rows_with_paid_time: 0,
          rows_with_cancelled_time: 0,
          rows_without_created_time: 0,
        }
      }
    }

    // Calculate coverage
    const totalRows = rawLines.length
    const distinctOrders = new Set(rawLines.map(l => l.external_order_id || l.order_id)).size
    const rowsWithCreatedTime = rawLines.filter(l => l.created_time).length
    const rowsWithPaidTime = rawLines.filter(l => l.paid_time).length
    const rowsWithCancelledTime = rawLines.filter(l => l.cancelled_time).length
    const rowsWithoutCreatedTime = totalRows - rowsWithCreatedTime

    return {
      success: true,
      data: {
        total_rows: totalRows,
        distinct_orders: distinctOrders,
        rows_with_created_time: rowsWithCreatedTime,
        rows_with_paid_time: rowsWithPaidTime,
        rows_with_cancelled_time: rowsWithCancelledTime,
        rows_without_created_time: rowsWithoutCreatedTime,
      }
    }
  } catch (error) {
    console.error('Unexpected error in getImportCoverage:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * =====================================================
 * ADMIN FUNCTIONS - Reset TikTok OrderSKUList Data
 * =====================================================
 */

export interface ResetTikTokResult {
  dry_run: boolean
  sales_orders_before: number
  import_batches_before: number
  sales_orders_deleted: number
  import_batches_deleted: number
  message: string
}

/**
 * Preview Reset TikTok OrderSKUList (Dry-run)
 * Returns counts of rows that would be deleted without actually deleting
 */
export async function previewResetTikTokOrderSkuList(): Promise<{
  success: boolean
  data?: ResetTikTokResult
  error?: string
}> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Call RPC function with dry_run=true
    const { data, error } = await supabase.rpc('reset_tiktok_ordersku_list', {
      p_dry_run: true,
    })

    if (error) {
      console.error('Error previewing reset:', error)
      return { success: false, error: `เกิดข้อผิดพลาด: ${error.message}` }
    }

    return { success: true, data }
  } catch (error) {
    console.error('Unexpected error in previewResetTikTokOrderSkuList:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Reset TikTok OrderSKUList (Execute Deletion)
 * ADMIN ONLY: Deletes sales_orders and import_batches for TikTok OrderSKUList
 * Requires admin role in user_roles table
 */
export async function resetTikTokOrderSkuList(): Promise<{
  success: boolean
  data?: ResetTikTokResult
  error?: string
}> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Call RPC function with dry_run=false (actual deletion)
    const { data, error } = await supabase.rpc('reset_tiktok_ordersku_list', {
      p_dry_run: false,
    })

    if (error) {
      console.error('Error executing reset:', error)
      // Check if it's an authorization error
      if (error.message.includes('Unauthorized') || error.message.includes('admin')) {
        return { success: false, error: 'ไม่มีสิทธิ์: เฉพาะ Admin เท่านั้นที่สามารถรีเซ็ตข้อมูลได้' }
      }
      return { success: false, error: `เกิดข้อผิดพลาด: ${error.message}` }
    }

    return { success: true, data }
  } catch (error) {
    console.error('Unexpected error in resetTikTokOrderSkuList:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Check if current user is admin
 * Used to conditionally show/hide admin-only UI elements
 */
export async function checkIsAdmin(): Promise<{
  success: boolean
  isAdmin: boolean
  error?: string
}> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, isAdmin: false, error: 'ไม่พบข้อมูลผู้ใช้' }
    }

    // Check user_roles table for admin role
    const { data, error } = await supabase
      .from('user_roles')
      .select('role')
      .eq('user_id', user.id)
      .single()

    if (error) {
      // If no role found, user is not admin
      if (error.code === 'PGRST116') {
        return { success: true, isAdmin: false }
      }
      console.error('Error checking admin status:', error)
      return { success: false, isAdmin: false, error: error.message }
    }

    return { success: true, isAdmin: data?.role === 'admin' }
  } catch (error) {
    console.error('Unexpected error in checkIsAdmin:', error)
    return {
      success: false,
      isAdmin: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

// ============================================
// GMV SUMMARY (3-CARD METRICS: B, C, LEAKAGE)
// ============================================

export interface GMVSummary {
  // B: GMV (Orders Created) by created_time date
  gmv_created: number
  orders_created: number

  // C: GMV (Fulfilled) by shipped_at date
  gmv_fulfilled: number
  orders_fulfilled: number

  // Leakage: B - C (cancellations + unfulfilled)
  leakage_amount: number
  leakage_pct: number
}

export interface GMVSummaryResult {
  success: boolean
  data?: GMVSummary
  error?: string
}

/**
 * Get GMV summary filtered by the same criteria as the orders table.
 *
 * COHORT APPROACH: Both Created and Fulfilled are computed from ONE cohort
 * of orders (defined by the selected date range + date basis). Fulfilled is
 * the subset of the cohort where shipped_at IS NOT NULL and status_group !=
 * 'ยกเลิกแล้ว'. This guarantees leakage = created − fulfilled ≥ 0 always.
 *
 * GMV per order = COALESCE(order_amount, SUM(total_amount per line)):
 *   - order_amount: written to sales_orders by the importer when available
 *   - SUM(total_amount): correct fallback for both Shopee (single-SKU) and
 *     TikTok (multi-SKU, since total_amount = unit_price × qty per line)
 */
/**
 * SQL verification helper (copy into Supabase SQL editor to cross-check UI):
 *
 * WITH per_order AS (
 *   SELECT
 *     COALESCE(external_order_id, order_id) AS order_key,
 *     MAX(order_amount)     AS order_amount_col,
 *     SUM(total_amount)     AS line_total_sum,
 *     MAX(shipped_at)       AS shipped_at,
 *     MAX(CASE WHEN status_group = 'ยกเลิกแล้ว' THEN 1 ELSE 0 END) AS is_cancelled
 *   FROM sales_orders
 *   WHERE created_by = '<uid>'
 *     AND source_platform = 'tiktok_shop'                        -- or remove for All
 *     AND order_date >= '2026-01-01' AND order_date < '2026-02-01'
 *   GROUP BY 1
 * )
 * SELECT
 *   COUNT(*)                                                       AS created_orders,
 *   SUM(COALESCE(NULLIF(order_amount_col,0), line_total_sum))      AS created_gmv,
 *   COUNT(*) FILTER (WHERE shipped_at IS NOT NULL AND is_cancelled=0) AS fulfilled_orders,
 *   SUM(COALESCE(NULLIF(order_amount_col,0), line_total_sum))
 *     FILTER (WHERE shipped_at IS NOT NULL AND is_cancelled=0)     AS fulfilled_gmv
 * FROM per_order;
 */
export async function getSalesGMVSummary(
  filters: ExportFilters,
  dateBasis: 'order' | 'paid' = 'order'
): Promise<GMVSummaryResult> {
  noStore() // Prevent caching for real-time GMV data
  const startedAt = Date.now()
  let requestError: string | null = null
  let totalRawLines = 0
  let pageFetches = 0

  console.log('[Sales][getSalesGMVSummary] start', {
    startDate: filters.startDate,
    endDate: filters.endDate,
    sourcePlatform: filters.sourcePlatform || 'all',
    dateBasis,
    hasStatus: Boolean(filters.status?.length),
    paymentStatus: filters.paymentStatus || 'all',
    hasSearch: Boolean(filters.search?.trim()),
  })

  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      requestError = authError?.message || 'unauthenticated'
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    if (!filters.startDate || !filters.endDate) {
      return {
        success: true,
        data: { gmv_created: 0, orders_created: 0, gmv_fulfilled: 0, orders_fulfilled: 0, leakage_amount: 0, leakage_pct: 0 },
      }
    }

    // Compute end-of-day Bangkok as ISO string (avoids cutting off late-night orders)
    const { toZonedTime } = await import('date-fns-tz')
    const { endOfDay } = await import('date-fns')
    const bangkokEndDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
    const endOfDayISO = endOfDay(bangkokEndDate).toISOString()

    // ===== Build base query (filters only — no range yet) =====
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let baseQuery: any = supabase
      .from('sales_orders')
      .select('external_order_id, order_id, order_amount, total_amount, shipped_at, status_group, created_time, order_date, paid_time')
      .eq('created_by', user.id)

    // Non-date filters
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    }
    if (filters.status && filters.status.length > 0) {
      baseQuery = baseQuery.in('platform_status', filters.status)
    }
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      baseQuery = baseQuery.eq('payment_status', filters.paymentStatus)
    }
    if (filters.search && filters.search.trim()) {
      baseQuery = baseQuery.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // Date filter — defines the cohort
    if (dateBasis === 'paid') {
      baseQuery = baseQuery
        .not('paid_time', 'is', null)
        .gte('paid_time', filters.startDate)
        .lte('paid_time', endOfDayISO)
    } else {
      // Fetch by order_date (broader); COALESCE(created_time, order_date) applied in TS
      baseQuery = baseQuery
        .gte('order_date', filters.startDate)
        .lte('order_date', endOfDayISO)
    }

    // ===== Paginated fetch — bypasses Supabase PostgREST default 1000-row cap =====
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    let allFetchedLines: any[] = []
    const PAGE_SIZE = 1000
    let from = 0
    let hasMore = true

    while (hasMore) {
      const { data: page, error: pageError } = await baseQuery.range(from, from + PAGE_SIZE - 1)
      pageFetches++

      if (pageError) {
        requestError = pageError.message
        return { success: false, error: `เกิดข้อผิดพลาด: ${pageError.message}` }
      }

      if (page && page.length > 0) {
        allFetchedLines = allFetchedLines.concat(page)
        hasMore = page.length === PAGE_SIZE
        from += PAGE_SIZE
      } else {
        hasMore = false
      }
    }

    totalRawLines = allFetchedLines.length

    // ===== COALESCE(created_time, order_date) client-side date filter (order basis) =====
    const cohortLines = dateBasis === 'order'
      ? allFetchedLines.filter((line: { created_time?: string | null; order_date?: string | null }) => {
          const effectiveDate = line.created_time || line.order_date
          if (!effectiveDate) return false
          const bangkokDateStr = toBangkokDateString(new Date(effectiveDate))
          if (filters.startDate && bangkokDateStr < filters.startDate) return false
          if (filters.endDate && bangkokDateStr > filters.endDate) return false
          return true
        })
      : allFetchedLines

    if (process.env.NODE_ENV === 'development') {
      console.log('[Sales][getSalesGMVSummary] lines fetched', {
        rawLines: totalRawLines,
        cohortLines: cohortLines.length,
        pageFetches,
        dateBasis,
        sourcePlatform: filters.sourcePlatform || 'all',
        dateRange: `${filters.startDate} → ${filters.endDate}`,
      })
    }

    if (cohortLines.length === 0) {
      return {
        success: true,
        data: { gmv_created: 0, orders_created: 0, gmv_fulfilled: 0, orders_fulfilled: 0, leakage_amount: 0, leakage_pct: 0 },
      }
    }

    // ===== Per-order aggregation =====
    //
    // GMV rule (per task spec):
    //   - If order_amount is non-null AND same across all lines  → use MAX(order_amount)
    //   - Otherwise                                              → use SUM(total_amount)
    //
    // This is equivalent to: COALESCE(NULLIF(MAX(order_amount), 0), SUM(total_amount))
    // when order_amount is either 0/null (not set) or the correct order total.
    //
    // Fulfilled = subset of cohort where shipped_at IS NOT NULL AND status_group != 'ยกเลิกแล้ว'
    interface OrderBucket {
      order_amounts: number[]  // All non-null order_amount values seen (for uniformity check)
      line_total_sum: number   // SUM(total_amount) across all lines
      shipped_at: string | null
      is_cancelled: boolean
    }

    const orderMap = new Map<string, OrderBucket>()

    for (const line of cohortLines) {
      const key = (line.external_order_id as string | null) || (line.order_id as string)
      const lineTotal = Number(line.total_amount ?? 0)
      const lineOrderAmt = (line.order_amount != null && Number(line.order_amount) > 0)
        ? Number(line.order_amount)
        : null
      const lineShipped = (line.shipped_at as string | null) ?? null
      const lineCancelled = (line.status_group as string | null) === 'ยกเลิกแล้ว'

      const existing = orderMap.get(key)
      if (!existing) {
        orderMap.set(key, {
          order_amounts: lineOrderAmt != null ? [lineOrderAmt] : [],
          line_total_sum: lineTotal,
          shipped_at: lineShipped,
          is_cancelled: lineCancelled,
        })
      } else {
        existing.line_total_sum += lineTotal
        if (lineOrderAmt != null) existing.order_amounts.push(lineOrderAmt)
        if (!existing.shipped_at && lineShipped) existing.shipped_at = lineShipped
        if (lineCancelled) existing.is_cancelled = true
      }
    }

    // Compute totals
    let gmv_created = 0, orders_created = 0, gmv_fulfilled = 0, orders_fulfilled = 0

    for (const data of Array.from(orderMap.values())) {
      // Use order_amount only if all collected values are identical (i.e. it's order-level)
      let gmv: number
      if (data.order_amounts.length > 0) {
        const first = data.order_amounts[0]
        const allSame = data.order_amounts.every((a) => a === first)
        gmv = allSame ? first : data.line_total_sum
      } else {
        gmv = data.line_total_sum
      }

      const is_fulfilled = !!data.shipped_at && !data.is_cancelled
      gmv_created += gmv
      orders_created++
      if (is_fulfilled) {
        gmv_fulfilled += gmv
        orders_fulfilled++
      }
    }

    gmv_created = Math.round(gmv_created * 100) / 100
    gmv_fulfilled = Math.round(gmv_fulfilled * 100) / 100
    const leakage_amount = Math.round((gmv_created - gmv_fulfilled) * 100) / 100
    const leakage_pct = gmv_created > 0
      ? Math.round((leakage_amount / gmv_created) * 100 * 100) / 100
      : 0

    if (process.env.NODE_ENV === 'development') {
      console.log('[Sales][getSalesGMVSummary] result', {
        created_orders: orders_created,
        created_gmv: gmv_created,
        fulfilled_orders: orders_fulfilled,
        fulfilled_gmv: gmv_fulfilled,
        leakage_amount,
        leakage_pct,
        distinct_order_keys: orderMap.size,
        total_lines: cohortLines.length,
      })
    }

    return {
      success: true,
      data: { gmv_created, orders_created, gmv_fulfilled, orders_fulfilled, leakage_amount, leakage_pct },
    }
  } catch (error) {
    console.error('Unexpected error in getSalesGMVSummary:', error)
    requestError = error instanceof Error ? error.message : 'unknown error'
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  } finally {
    console.log('[Sales][getSalesGMVSummary] end', {
      durationMs: Date.now() - startedAt,
      startDate: filters.startDate,
      endDate: filters.endDate,
      dateBasis,
      sourcePlatform: filters.sourcePlatform || 'all',
      totalRawLines,
      pageFetches,
      error: requestError,
    })
  }
}
