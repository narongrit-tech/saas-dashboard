'use server'

import { createClient } from '@/lib/supabase/server'
import { CreateOrderInput, UpdateOrderInput } from '@/types/sales'
import { toBangkokTime, formatBangkok, getBangkokNow } from '@/lib/bangkok-time'

interface ActionResult {
  success: boolean
  error?: string
  data?: unknown
}

export async function createManualOrder(input: CreateOrderInput): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Validate input
    if (!input.product_name || input.product_name.trim() === '') {
      return { success: false, error: 'กรุณากระอกชื่อสินค้า' }
    }

    if (input.quantity <= 0) {
      return { success: false, error: 'จำนวนต้องมากกว่า 0' }
    }

    if (input.unit_price < 0) {
      return { success: false, error: 'ราคาต่อหน่วยต้องไม่ติดลบ' }
    }

    if (!input.order_date) {
      return { success: false, error: 'กรุณาระบุวันที่สั่งซื้อ' }
    }

    // 3. Calculate total_amount (server-side, cannot be trusted from client)
    // BUSINESS RULE: Total amount must be calculated server-side to prevent tampering
    // BUSINESS RULE: Cancelled orders must have total_amount = 0 (excluded from revenue)
    // FINANCIAL SAFETY: Round to 2 decimal places (currency precision)
    let totalAmount: number

    if (input.status.toLowerCase() === 'cancelled') {
      totalAmount = 0
    } else {
      const rawAmount = input.quantity * input.unit_price
      // Round to 2 decimal places to prevent floating point errors
      totalAmount = Math.round(rawAmount * 100) / 100
    }

    // 4. Generate order_id in format: MAN-YYYYMMDD-XXX
    const orderDate = toBangkokTime(input.order_date)
    const dateStr = formatBangkok(orderDate, 'yyyyMMdd')
    const prefix = `MAN-${dateStr}`

    // Query existing manual orders for today to get counter
    const { data: existingOrders, error: queryError } = await supabase
      .from('sales_orders')
      .select('order_id')
      .ilike('order_id', `${prefix}%`)
      .order('order_id', { ascending: false })
      .limit(1)

    if (queryError) {
      console.error('Error querying existing orders:', queryError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการตรวจสอบ order id' }
    }

    let counter = 1
    if (existingOrders && existingOrders.length > 0) {
      const lastOrderId = existingOrders[0].order_id
      const lastCounter = parseInt(lastOrderId.split('-')[2] || '0')
      counter = lastCounter + 1
    }

    const orderId = `${prefix}-${counter.toString().padStart(3, '0')}`

    // 5. Insert order into database
    // AUDIT SAFETY: Every record must have source and created_by for traceability
    // source = 'manual' | 'csv' | 'api' - identifies data origin
    // created_by = user.id - tracks who created this record
    // created_at = auto-generated by Supabase - timestamp
    // CRITICAL: Manual entries must never be overwritten by imports
    const { data: insertedOrder, error: insertError } = await supabase
      .from('sales_orders')
      .insert({
        order_id: orderId,
        marketplace: input.marketplace,
        product_name: input.product_name.trim(),
        quantity: input.quantity,
        unit_price: input.unit_price,
        total_amount: totalAmount,
        order_date: input.order_date,
        status: input.status,
        source: 'manual', // AUDIT: Mark as manually entered
        created_by: user.id, // AUDIT: Track creator
      })
      .select()
      .single()

    if (insertError) {
      console.error('Error inserting order:', insertError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${insertError.message}` }
    }

    return { success: true, data: insertedOrder }
  } catch (error) {
    console.error('Unexpected error in createManualOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

export async function updateOrder(
  orderId: string,
  input: UpdateOrderInput
): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Validate input
    if (!input.product_name || input.product_name.trim() === '') {
      return { success: false, error: 'กรุณากรอกชื่อสินค้า' }
    }

    if (input.quantity <= 0) {
      return { success: false, error: 'จำนวนต้องมากกว่า 0' }
    }

    if (input.unit_price < 0) {
      return { success: false, error: 'ราคาต่อหน่วยต้องไม่ติดลบ' }
    }

    if (!input.order_date) {
      return { success: false, error: 'กรุณาระบุวันที่สั่งซื้อ' }
    }

    // 3. Check if order exists and belongs to user (RLS will also enforce this)
    const { data: existingOrder, error: fetchError } = await supabase
      .from('sales_orders')
      .select('id, created_by')
      .eq('id', orderId)
      .single()

    if (fetchError || !existingOrder) {
      return { success: false, error: 'ไม่พบรายการ order ที่ต้องการแก้ไข' }
    }

    // Check ownership (defensive - RLS should also prevent this)
    if (existingOrder.created_by !== user.id) {
      return { success: false, error: 'คุณไม่มีสิทธิ์แก้ไข order นี้' }
    }

    // 4. Calculate total_amount (server-side, cannot be trusted from client)
    let totalAmount: number

    if (input.status.toLowerCase() === 'cancelled') {
      totalAmount = 0
    } else {
      const rawAmount = input.quantity * input.unit_price
      totalAmount = Math.round(rawAmount * 100) / 100
    }

    // 5. Update order in database
    const { data: updatedOrder, error: updateError } = await supabase
      .from('sales_orders')
      .update({
        marketplace: input.marketplace,
        product_name: input.product_name.trim(),
        quantity: input.quantity,
        unit_price: input.unit_price,
        total_amount: totalAmount,
        order_date: input.order_date,
        status: input.status,
        updated_at: new Date().toISOString(),
      })
      .eq('id', orderId)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating order:', updateError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${updateError.message}` }
    }

    return { success: true, data: updatedOrder }
  } catch (error) {
    console.error('Unexpected error in updateOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

export async function deleteOrder(orderId: string): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Check if order exists and belongs to user (RLS will also enforce this)
    const { data: existingOrder, error: fetchError } = await supabase
      .from('sales_orders')
      .select('id, created_by, order_id')
      .eq('id', orderId)
      .single()

    if (fetchError || !existingOrder) {
      return { success: false, error: 'ไม่พบรายการ order ที่ต้องการลบ' }
    }

    // Check ownership (defensive - RLS should also prevent this)
    if (existingOrder.created_by !== user.id) {
      return { success: false, error: 'คุณไม่มีสิทธิ์ลบ order นี้' }
    }

    // 3. Hard delete from database
    const { error: deleteError } = await supabase
      .from('sales_orders')
      .delete()
      .eq('id', orderId)

    if (deleteError) {
      console.error('Error deleting order:', deleteError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${deleteError.message}` }
    }

    return { success: true, data: { deletedId: orderId } }
  } catch (error) {
    console.error('Unexpected error in deleteOrder:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

interface ExportFilters {
  marketplace?: string // Legacy (keep for backward compat)
  sourcePlatform?: string // UX v2: tiktok_shop | shopee | etc
  status?: string[] // UX v2: Multi-select status filter
  paymentStatus?: string // UX v2: paid | unpaid
  startDate?: string
  endDate?: string
  search?: string
}

interface ExportResult {
  success: boolean
  error?: string
  csv?: string
  filename?: string
}

/**
 * Export Sales Orders to CSV
 * Respects all filters (marketplace, date range, search)
 * Returns CSV content and filename with Bangkok timezone
 */
export async function exportSalesOrders(filters: ExportFilters): Promise<ExportResult> {
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Build query with filters (UX v2 logic)
    let query = supabase
      .from('sales_orders')
      .select('*')
      .order('order_date', { ascending: false })

    // Platform filter (UX v2)
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      query = query.eq('source_platform', filters.sourcePlatform)
    } else if (filters.marketplace && filters.marketplace !== 'All') {
      // Legacy fallback
      query = query.eq('marketplace', filters.marketplace)
    }

    // Status filter (multi-select, UX v2) - filters by platform_status (Thai values)
    if (filters.status && filters.status.length > 0) {
      query = query.in('platform_status', filters.status)
    }

    // Payment status filter (UX v2)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      query = query.eq('payment_status', filters.paymentStatus)
    }

    // Apply date filters
    if (filters.startDate) {
      query = query.gte('order_date', filters.startDate)
    }

    if (filters.endDate) {
      // Use Bangkok timezone for end of day
      const { toZonedTime } = await import('date-fns-tz')
      const { endOfDay } = await import('date-fns')
      const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
      const endOfDayBangkok = endOfDay(bangkokDate)
      query = query.lte('order_date', endOfDayBangkok.toISOString())
    }

    // Apply search filter (UX v2 includes external_order_id)
    if (filters.search && filters.search.trim()) {
      query = query.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // No pagination - export all matching records
    // Add reasonable limit to prevent memory issues
    query = query.limit(10000)

    const { data: orders, error: fetchError } = await query

    if (fetchError) {
      console.error('Error fetching orders for export:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!orders || orders.length === 0) {
      return { success: false, error: 'ไม่พบข้อมูลที่จะ export' }
    }

    // 3. Generate CSV content (UX v2 with platform status & payment)
    // CSV Headers (English for Excel compatibility)
    const headers = [
      'Order ID',
      'External Order ID',
      'Platform',
      'Product Name',
      'Quantity',
      'Unit Price',
      'Total Amount',
      'Internal Status',
      'Platform Status',
      'Status Group',
      'Payment Status',
      'Paid Date',
      'Order Date',
      'Created At',
    ]

    // Escape CSV field (handle commas, quotes, newlines)
    const escapeCSV = (value: string | number | null | undefined): string => {
      if (value === null || value === undefined) return ''
      const str = String(value)
      // If contains comma, quote, or newline, wrap in quotes and escape quotes
      if (str.includes(',') || str.includes('"') || str.includes('\n')) {
        return `"${str.replace(/"/g, '""')}"`
      }
      return str
    }

    // Build CSV rows (UX v2 with platform status & payment)
    const rows = orders.map((order) => {
      return [
        escapeCSV(order.order_id),
        escapeCSV(order.external_order_id || ''),
        escapeCSV(order.source_platform || order.marketplace),
        escapeCSV(order.product_name),
        escapeCSV(order.quantity),
        escapeCSV(order.unit_price),
        escapeCSV(order.total_amount),
        escapeCSV(order.status),
        escapeCSV(order.platform_status || ''),
        escapeCSV(order.status_group || ''),
        escapeCSV(order.payment_status || ''),
        escapeCSV(order.paid_at || ''),
        escapeCSV(order.order_date),
        escapeCSV(order.created_at),
      ].join(',')
    })

    // Combine headers and rows
    const csvContent = [headers.join(','), ...rows].join('\n')

    // 4. Generate filename with Bangkok timezone
    const now = getBangkokNow()
    const dateStr = formatBangkok(now, 'yyyyMMdd-HHmmss')
    const filename = `sales-orders-${dateStr}.csv`

    return {
      success: true,
      csv: csvContent,
      filename,
    }
  } catch (error) {
    console.error('Unexpected error in exportSalesOrders:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Get Sales Aggregates (Summary Metrics)
 * Computes summary metrics for Sales Orders page
 * Uses SAME filters as getSalesOrders to prevent drift
 *
 * CRITICAL: Uses paid_at for date filtering (not order_date)
 * Only paid orders contribute to revenue metrics
 */
export interface SalesAggregates {
  revenue_paid_excl_cancel: number // Revenue (paid, exclude cancelled)
  cancelled_amount: number // Total cancelled amount
  net_after_cancel: number // Net revenue after cancellations
  orders_excl_cancel: number // Order count (exclude cancelled)
  cancelled_orders: number // Cancelled order count
  units_excl_cancel: number // Total units (exclude cancelled)
  aov_net: number // Average Order Value (net / orders)
}

export async function getSalesAggregates(filters: ExportFilters): Promise<{
  success: boolean
  data?: SalesAggregates
  error?: string
}> {
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Build base query with filters (SAME as exportSalesOrders)
    let baseQuery = supabase
      .from('sales_orders')
      .select('*')

    // Platform filter (UX v2)
    if (filters.sourcePlatform && filters.sourcePlatform !== 'all') {
      baseQuery = baseQuery.eq('source_platform', filters.sourcePlatform)
    } else if (filters.marketplace && filters.marketplace !== 'All') {
      // Legacy fallback
      baseQuery = baseQuery.eq('marketplace', filters.marketplace)
    }

    // Status filter (multi-select, UX v2) - filters by platform_status (Thai values)
    if (filters.status && filters.status.length > 0) {
      baseQuery = baseQuery.in('platform_status', filters.status)
    }

    // Payment status filter (UX v2)
    if (filters.paymentStatus && filters.paymentStatus !== 'all') {
      baseQuery = baseQuery.eq('payment_status', filters.paymentStatus)
    }

    // CRITICAL: Use paid_at for date filtering (not order_date)
    // Only orders with paid_at contribute to revenue
    if (filters.startDate) {
      baseQuery = baseQuery.gte('paid_at', filters.startDate)
    }

    if (filters.endDate) {
      // Use Bangkok timezone for end of day
      const { toZonedTime } = await import('date-fns-tz')
      const { endOfDay } = await import('date-fns')
      const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
      const endOfDayBangkok = endOfDay(bangkokDate)
      baseQuery = baseQuery.lte('paid_at', endOfDayBangkok.toISOString())
    }

    // Apply search filter (UX v2 includes external_order_id)
    if (filters.search && filters.search.trim()) {
      baseQuery = baseQuery.or(
        `order_id.ilike.%${filters.search}%,product_name.ilike.%${filters.search}%,external_order_id.ilike.%${filters.search}%`
      )
    }

    // 3. Fetch all matching orders (we need to compute aggregates in code)
    const { data: orders, error: fetchError } = await baseQuery

    if (fetchError) {
      console.error('Error fetching orders for aggregates:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!orders || orders.length === 0) {
      // Return zero aggregates if no data
      return {
        success: true,
        data: {
          revenue_paid_excl_cancel: 0,
          cancelled_amount: 0,
          net_after_cancel: 0,
          orders_excl_cancel: 0,
          cancelled_orders: 0,
          units_excl_cancel: 0,
          aov_net: 0,
        },
      }
    }

    // 4. Compute aggregates
    let revenuePaidExclCancel = 0
    let cancelledAmount = 0
    let ordersExclCancel = 0
    let cancelledOrders = 0
    let unitsExclCancel = 0

    for (const order of orders) {
      const isCancelled = order.platform_status?.toLowerCase().includes('ยกเลิก')

      if (isCancelled) {
        cancelledAmount += order.total_amount || 0
        cancelledOrders += 1
      } else {
        revenuePaidExclCancel += order.total_amount || 0
        ordersExclCancel += 1
        unitsExclCancel += order.quantity || 0
      }
    }

    // 5. Calculate derived metrics
    const netAfterCancel = revenuePaidExclCancel - cancelledAmount
    const aovNet = ordersExclCancel > 0 ? netAfterCancel / ordersExclCancel : 0

    return {
      success: true,
      data: {
        revenue_paid_excl_cancel: Math.round(revenuePaidExclCancel * 100) / 100,
        cancelled_amount: Math.round(cancelledAmount * 100) / 100,
        net_after_cancel: Math.round(netAfterCancel * 100) / 100,
        orders_excl_cancel: ordersExclCancel,
        cancelled_orders: cancelledOrders,
        units_excl_cancel: unitsExclCancel,
        aov_net: Math.round(aovNet * 100) / 100,
      },
    }
  } catch (error) {
    console.error('Unexpected error in getSalesAggregates:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}
