'use server'

import { createClient } from '@/lib/supabase/server'
import { sanitizeCSVField } from '@/lib/csv'
import { CreateExpenseInput, UpdateExpenseInput, ExpenseCategory } from '@/types/expenses'
import { getBangkokNow, formatBangkok } from '@/lib/bangkok-time'

interface ActionResult {
  success: boolean
  error?: string
  data?: unknown
}

// BUSINESS RULE: Expenses must be categorized into exactly 3 types
// - Advertising: ค่าโฆษณา (ads, marketing spend)
// - COGS: ต้นทุนขาย (cost of goods sold - product cost, packaging)
// - Operating: ค่าดำเนินงาน (overhead, utilities, salaries, etc.)
const VALID_CATEGORIES: ExpenseCategory[] = ['Advertising', 'COGS', 'Operating']

export async function createManualExpense(input: CreateExpenseInput): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Validate input
    if (!input.expense_date || input.expense_date.trim() === '') {
      return { success: false, error: 'กรุณาระบุวันที่รายจ่าย' }
    }

    if (!VALID_CATEGORIES.includes(input.category)) {
      return { success: false, error: 'หมวดหมู่รายจ่ายไม่ถูกต้อง' }
    }

    if (input.amount <= 0) {
      return { success: false, error: 'จำนวนเงินต้องมากกว่า 0' }
    }

    // FINANCIAL SAFETY: Round amount to 2 decimal places (currency precision)
    const roundedAmount = Math.round(input.amount * 100) / 100

    // 3. Prepare description (use note or default)
    const description = input.note && input.note.trim() !== ''
      ? input.note.trim()
      : 'รายจ่ายทั่วไป'

    // 4. Insert expense into database
    // AUDIT SAFETY: Every expense must have source and created_by for traceability
    // source = 'manual' | 'csv' | 'api' - identifies data origin
    // created_by = user.id - tracks who entered this expense
    // created_at = auto-generated by Supabase - timestamp
    // CRITICAL: Manual expenses must never be overwritten by imports
    const { data: insertedExpense, error: insertError } = await supabase
      .from('expenses')
      .insert({
        category: input.category,
        subcategory: input.subcategory || null, // Optional subcategory (nullable)
        amount: roundedAmount, // Use rounded amount for financial precision
        expense_date: input.expense_date,
        description: description,
        source: 'manual', // AUDIT: Mark as manually entered
        created_by: user.id, // AUDIT: Track creator
      })
      .select()
      .single()

    if (insertError) {
      console.error('Error inserting expense:', insertError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${insertError.message}` }
    }

    // 5. Create audit log (CREATE action)
    await supabase.rpc('create_expense_audit_log', {
      p_expense_id: insertedExpense.id,
      p_action: 'CREATE',
      p_performed_by: user.id,
      p_changes: {
        created: {
          category: input.category,
          subcategory: input.subcategory || null,
          amount: roundedAmount,
          expense_date: input.expense_date,
          description,
        },
      },
    })

    return { success: true, data: insertedExpense }
  } catch (error) {
    console.error('Unexpected error in createManualExpense:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

export async function updateExpense(
  expenseId: string,
  input: UpdateExpenseInput
): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Validate input
    if (!input.expense_date || input.expense_date.trim() === '') {
      return { success: false, error: 'กรุณาระบุวันที่รายจ่าย' }
    }

    if (!VALID_CATEGORIES.includes(input.category)) {
      return { success: false, error: 'หมวดหมู่รายจ่ายไม่ถูกต้อง' }
    }

    if (input.amount <= 0) {
      return { success: false, error: 'จำนวนเงินต้องมากกว่า 0' }
    }

    // 3. Check if expense exists and belongs to user (RLS will also enforce this)
    const { data: existingExpense, error: fetchError } = await supabase
      .from('expenses')
      .select('*')
      .eq('id', expenseId)
      .single()

    if (fetchError || !existingExpense) {
      return { success: false, error: 'ไม่พบรายการค่าใช้จ่ายที่ต้องการแก้ไข' }
    }

    // Check ownership (defensive - RLS should also prevent this)
    if (existingExpense.created_by !== user.id) {
      return { success: false, error: 'คุณไม่มีสิทธิ์แก้ไขรายการนี้' }
    }

    // 4. Round amount for financial precision
    const roundedAmount = Math.round(input.amount * 100) / 100

    // 5. Prepare description
    const description = input.note && input.note.trim() !== ''
      ? input.note.trim()
      : 'รายจ่ายทั่วไป'

    // 6. Update expense in database
    const { data: updatedExpense, error: updateError } = await supabase
      .from('expenses')
      .update({
        category: input.category,
        subcategory: input.subcategory || null, // Optional subcategory (nullable)
        amount: roundedAmount,
        expense_date: input.expense_date,
        description: description,
        updated_at: new Date().toISOString(),
      })
      .eq('id', expenseId)
      .select()
      .single()

    if (updateError) {
      console.error('Error updating expense:', updateError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${updateError.message}` }
    }

    // 7. Create audit log (UPDATE action)
    await supabase.rpc('create_expense_audit_log', {
      p_expense_id: expenseId,
      p_action: 'UPDATE',
      p_performed_by: user.id,
      p_changes: {
        before: {
          category: existingExpense.category,
          subcategory: existingExpense.subcategory || null,
          amount: existingExpense.amount,
          expense_date: existingExpense.expense_date,
          description: existingExpense.description,
        },
        after: {
          category: input.category,
          subcategory: input.subcategory || null,
          amount: roundedAmount,
          expense_date: input.expense_date,
          description,
        },
      },
    })

    return { success: true, data: updatedExpense }
  } catch (error) {
    console.error('Unexpected error in updateExpense:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

export async function deleteExpense(expenseId: string): Promise<ActionResult> {
  try {
    // 1. Create Supabase server client and get user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Check if expense exists and belongs to user (RLS will also enforce this)
    const { data: existingExpense, error: fetchError } = await supabase
      .from('expenses')
      .select('*')
      .eq('id', expenseId)
      .single()

    if (fetchError || !existingExpense) {
      return { success: false, error: 'ไม่พบรายการค่าใช้จ่ายที่ต้องการลบ' }
    }

    // Check ownership (defensive - RLS should also prevent this)
    if (existingExpense.created_by !== user.id) {
      return { success: false, error: 'คุณไม่มีสิทธิ์ลบรายการนี้' }
    }

    // 3. Create audit log BEFORE deleting (DELETE action)
    await supabase.rpc('create_expense_audit_log', {
      p_expense_id: expenseId,
      p_action: 'DELETE',
      p_performed_by: user.id,
      p_changes: {
        deleted: {
          category: existingExpense.category,
          subcategory: existingExpense.subcategory || null,
          amount: existingExpense.amount,
          expense_date: existingExpense.expense_date,
          description: existingExpense.description,
        },
      },
    })

    // 4. Hard delete from database
    const { error: deleteError } = await supabase
      .from('expenses')
      .delete()
      .eq('id', expenseId)

    if (deleteError) {
      console.error('Error deleting expense:', deleteError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${deleteError.message}` }
    }

    return { success: true, data: { deletedId: expenseId } }
  } catch (error) {
    console.error('Unexpected error in deleteExpense:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

interface ExportFilters {
  category?: string
  startDate?: string
  endDate?: string
  search?: string
}

interface ExportResult {
  success: boolean
  error?: string
  csv?: string
  filename?: string
}

// Bulk selection types
export type SelectionMode = 'ids' | 'filtered'

export interface BulkSelectionFilters {
  category?: string
  startDate?: string
  endDate?: string
  search?: string
}

export interface SelectionSummary {
  success: boolean
  error?: string
  count?: number
  sumAmount?: number
  deletableCount?: number
  blockedCount?: number
  blockedReason?: string
}

export interface BulkDeleteResult {
  success: boolean
  error?: string
  deletedCount?: number
  blockedCount?: number
}

/**
 * Get summary of selected expenses
 * Mode 'ids': counts specific expense IDs
 * Mode 'filtered': counts all matching filter criteria
 * Returns count, sum, and deletable/blocked counts
 */
export async function getExpensesSelectionSummary(
  mode: SelectionMode,
  filters?: BulkSelectionFilters,
  ids?: string[]
): Promise<SelectionSummary> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    let query = supabase.from('expenses').select('id, amount, source, created_by')

    // Mode: specific IDs
    if (mode === 'ids') {
      if (!ids || ids.length === 0) {
        return {
          success: true,
          count: 0,
          sumAmount: 0,
          deletableCount: 0,
          blockedCount: 0,
        }
      }
      query = query.in('id', ids)
    }

    // Mode: filtered
    if (mode === 'filtered' && filters) {
      if (filters.category && filters.category !== 'All') {
        query = query.eq('category', filters.category)
      }

      if (filters.startDate) {
        query = query.gte('expense_date', filters.startDate)
      }

      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        query = query.lte('expense_date', endOfDayBangkok.toISOString())
      }

      if (filters.search && filters.search.trim()) {
        query = query.or(
          `description.ilike.%${filters.search}%,notes.ilike.%${filters.search}%`
        )
      }
    }

    const { data, error } = await query

    if (error) {
      console.error('Error fetching selection summary:', error)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!data || data.length === 0) {
      return {
        success: true,
        count: 0,
        sumAmount: 0,
        deletableCount: 0,
        blockedCount: 0,
      }
    }

    // Filter: user can only delete their own expenses (RLS enforcement)
    const ownExpenses = data.filter((e) => e.created_by === user.id)

    // Calculate summary
    const count = ownExpenses.length
    const sumAmount = ownExpenses.reduce((sum, e) => sum + e.amount, 0)
    const blockedCount = data.length - ownExpenses.length

    return {
      success: true,
      count,
      sumAmount: Math.round(sumAmount * 100) / 100, // Round to 2 decimals
      deletableCount: count,
      blockedCount,
      blockedReason: blockedCount > 0
        ? 'บางรายการไม่สามารถลบได้เนื่องจากไม่ใช่รายการของคุณ'
        : undefined,
    }
  } catch (error) {
    console.error('Unexpected error in getExpensesSelectionSummary:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Delete selected expenses in bulk
 * Mode 'ids': deletes specific expense IDs
 * Mode 'filtered': deletes all matching filter criteria
 * Creates audit logs for all deleted expenses
 * Respects RLS: only deletes user's own expenses
 */
export async function deleteExpensesSelected(
  mode: SelectionMode,
  filters?: BulkSelectionFilters,
  ids?: string[]
): Promise<BulkDeleteResult> {
  try {
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // Step 1: Fetch expenses to delete (with full data for audit logs)
    let query = supabase
      .from('expenses')
      .select('*')
      .eq('created_by', user.id) // RLS: Only user's own expenses

    // Mode: specific IDs
    if (mode === 'ids') {
      if (!ids || ids.length === 0) {
        return {
          success: true,
          deletedCount: 0,
          blockedCount: 0,
        }
      }
      query = query.in('id', ids)
    }

    // Mode: filtered
    if (mode === 'filtered' && filters) {
      if (filters.category && filters.category !== 'All') {
        query = query.eq('category', filters.category)
      }

      if (filters.startDate) {
        query = query.gte('expense_date', filters.startDate)
      }

      if (filters.endDate) {
        const { toZonedTime } = await import('date-fns-tz')
        const { endOfDay } = await import('date-fns')
        const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
        const endOfDayBangkok = endOfDay(bangkokDate)
        query = query.lte('expense_date', endOfDayBangkok.toISOString())
      }

      if (filters.search && filters.search.trim()) {
        query = query.or(
          `description.ilike.%${filters.search}%,notes.ilike.%${filters.search}%`
        )
      }
    }

    const { data: expensesToDelete, error: fetchError } = await query

    if (fetchError) {
      console.error('Error fetching expenses to delete:', fetchError)
      return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
    }

    if (!expensesToDelete || expensesToDelete.length === 0) {
      return {
        success: true,
        deletedCount: 0,
        blockedCount: 0,
      }
    }

    // Step 2: Create audit logs for all expenses (BEFORE deletion)
    const auditPromises = expensesToDelete.map((expense) =>
      supabase.rpc('create_expense_audit_log', {
        p_expense_id: expense.id,
        p_action: 'DELETE',
        p_performed_by: user.id,
        p_changes: {
          deleted: {
            category: expense.category,
            subcategory: expense.subcategory || null,
            amount: expense.amount,
            expense_date: expense.expense_date,
            description: expense.description,
          },
        },
      })
    )

    await Promise.all(auditPromises)

    // Step 3: Bulk delete expenses (single query)
    const expenseIds = expensesToDelete.map((e) => e.id)
    const { error: deleteError } = await supabase
      .from('expenses')
      .delete()
      .in('id', expenseIds)
      .eq('created_by', user.id) // Double-check RLS

    if (deleteError) {
      console.error('Error deleting expenses:', deleteError)
      return { success: false, error: `เกิดข้อผิดพลาด: ${deleteError.message}` }
    }

    return {
      success: true,
      deletedCount: expensesToDelete.length,
      blockedCount: 0,
    }
  } catch (error) {
    console.error('Unexpected error in deleteExpensesSelected:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}

/**
 * Export Expenses to CSV
 * Respects all filters (category, date range, search)
 * Returns CSV content and filename with Bangkok timezone
 */
export async function exportExpenses(filters: ExportFilters): Promise<ExportResult> {
  try {
    // 1. Authenticate user
    const supabase = createClient()
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { success: false, error: 'ไม่พบข้อมูลผู้ใช้ กรุณา login ใหม่' }
    }

    // 2. Build query with filters (same logic as page query)
    let query = supabase
      .from('expenses')
      .select('*')
      .order('expense_date', { ascending: false })

    // Apply category filter
    if (filters.category && filters.category !== 'All') {
      query = query.eq('category', filters.category)
    }

    // Apply date filters
    if (filters.startDate) {
      query = query.gte('expense_date', filters.startDate)
    }

    if (filters.endDate) {
      // Use Bangkok timezone for end of day
      const { toZonedTime } = await import('date-fns-tz')
      const { endOfDay } = await import('date-fns')
      const bangkokDate = toZonedTime(new Date(filters.endDate), 'Asia/Bangkok')
      const endOfDayBangkok = endOfDay(bangkokDate)
      query = query.lte('expense_date', endOfDayBangkok.toISOString())
    }

    // Apply search filter
    if (filters.search && filters.search.trim()) {
      query = query.or(
        `description.ilike.%${filters.search}%,notes.ilike.%${filters.search}%`
      )
    }

    // PAGINATION: Handle more than 1000 rows (Supabase limit)
    let allExpenses: any[] = []
    let from = 0
    const pageSize = 1000
    let hasMore = true

    while (hasMore) {
      const { data, error } = await query.range(from, from + pageSize - 1)

      if (error) {
        console.error('Error fetching expenses for export:', error)
        return { success: false, error: 'เกิดข้อผิดพลาดในการดึงข้อมูล' }
      }

      if (data && data.length > 0) {
        allExpenses = allExpenses.concat(data)
        hasMore = data.length === pageSize
        from += pageSize
      } else {
        hasMore = false
      }
    }

    if (allExpenses.length === 0) {
      return { success: false, error: 'ไม่พบข้อมูลที่จะ export' }
    }

    const expenses = allExpenses

    // 3. Generate CSV content
    // CSV Headers (English for Excel compatibility)
    const headers = [
      'Expense Date',
      'Category',
      'Subcategory',
      'Amount',
      'Description',
      'Notes',
      'Created At',
    ]

    // Build CSV rows
    const rows = expenses.map((expense) => {
      return [
        sanitizeCSVField(expense.expense_date),
        sanitizeCSVField(expense.category),
        sanitizeCSVField(expense.subcategory || ''),
        sanitizeCSVField(expense.amount),
        sanitizeCSVField(expense.description),
        sanitizeCSVField(expense.notes || ''),
        sanitizeCSVField(expense.created_at),
      ].join(',')
    })

    // Combine headers and rows
    const csvContent = [headers.join(','), ...rows].join('\n')

    // 4. Generate filename with Bangkok timezone
    const now = getBangkokNow()
    const dateStr = formatBangkok(now, 'yyyyMMdd-HHmmss')
    const filename = `expenses-${dateStr}.csv`

    return {
      success: true,
      csv: csvContent,
      filename,
    }
  } catch (error) {
    console.error('Unexpected error in exportExpenses:', error)
    return {
      success: false,
      error: error instanceof Error ? error.message : 'เกิดข้อผิดพลาดที่ไม่คาดคิด',
    }
  }
}
